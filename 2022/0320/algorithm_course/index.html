<!DOCTYPE html>
<html lang="">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Lethe">


    <meta name="subtitle" content="Life is a struggle">


    <meta name="description" content="Lethe's Blog">


    <meta name="keywords" content="Lethe's Blog">


<title>算法分析与设计(USTC 2022春) | Lethe&#39;s Blog</title>



    <link rel="icon" href="https://s2.ax1x.com/2019/10/30/K5JenU.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Lethe&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Lethe&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">算法分析与设计(USTC 2022春)</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Lethe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 20, 2022&nbsp;&nbsp;16:04:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Algorithm/">Algorithm</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1 算法分析"></a>1 算法分析</h1><h2 id="1-1-渐近分析的记号"><a href="#1-1-渐近分析的记号" class="headerlink" title="1.1 渐近分析的记号"></a>1.1 渐近分析的记号</h2><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220528143943343.png" alt="image-20220528143943343" style="zoom:30%;">

<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220528143952643.png" alt="image-20220528143952643" style="zoom:30%;">

<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220528143959881.png" alt="image-20220528143959881" style="zoom:30%;">

<h2 id="1-2-主定理"><a href="#1-2-主定理" class="headerlink" title="1.2 主定理"></a>1.2 主定理</h2><p>主定理方法应用于如下的递归形式：$T(n) &#x3D; aT(n&#x2F;b) + f (n) $，其中，$a\geq1, b \geq 1$，$f$ 是渐近正的。</p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220528152727167.png" alt="image-20220528152727167" style="zoom:30%;">

<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620185155793.png" alt="image-20220601094053688" style="zoom:35%;">


<h1 id="2-分治与递归"><a href="#2-分治与递归" class="headerlink" title="2 分治与递归"></a>2 分治与递归</h1><h2 id="2-1-阶乘函数"><a href="#2-1-阶乘函数" class="headerlink" title="2.1 阶乘函数"></a>2.1 阶乘函数</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320161510908.png" alt="image-20220320161510908"></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阶乘函数</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">factorial</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Fibonacci数列"><a href="#2-2-Fibonacci数列" class="headerlink" title="2.2 Fibonacci数列"></a>2.2 Fibonacci数列</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320161403851.png" alt="image-20220320161403851"></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fibonacci数列</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fibonacci</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-全排列问题"><a href="#2-3-全排列问题" class="headerlink" title="2.3 全排列问题"></a>2.3 全排列问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320161642543.png" alt="image-20220320161642543"></p>
<p>思路：</p>
<ul>
<li>定义函数<code>perm(int list[], int k, int m)</code>表示获取<code>list[k:m]</code>的全排列。</li>
<li>递归条件：<ul>
<li>当<code>n=1</code>时，全排列只有一种，即为它本身。</li>
<li>当<code>n&gt;1</code>时，可以依次将每一个数作为前缀，然后对后续<code>n-1</code>个数进行全排列。</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全排列</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生list[k:m]的全排列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">perm</span><span class="params">(<span class="type">int</span> list[], <span class="type">int</span> k, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == m) &#123; <span class="comment">//只剩一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt;=m;i++)&#123;</span><br><span class="line">            cout &lt;&lt; list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//还有多个元素，递归产生排列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i&lt;=m; i++) &#123; </span><br><span class="line">            <span class="comment">//k到m的元素依次作为前缀,生成剩余数的全排列</span></span><br><span class="line">            <span class="built_in">swap</span>(list[k], list[i]);</span><br><span class="line">            <span class="built_in">perm</span>(list, k+<span class="number">1</span>, m);</span><br><span class="line">            <span class="built_in">swap</span>(list[k], list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">perm</span>(a, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-整数划分问题"><a href="#2-4-整数划分问题" class="headerlink" title="2.4 整数划分问题"></a>2.4 整数划分问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320162315684.png" alt="image-20220320162315684"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320162341988.png" alt="image-20220320162341988"></p>
<p>（1）递归解法</p>
<p>思路：对整数n进行划分，将最大加数不大于m的划分个数记作 $q(n,m)$</p>
<p>对于$q(n,m)$：</p>
<ul>
<li><p>当<code>n=1,m=1</code>时，整数划分只有一种结果</p>
</li>
<li><p>当<code>n&lt;m</code>时，<code>q(n,m)</code>等价于<code>q(n,n)</code></p>
</li>
<li><p>当<code>n=m</code>时，共有<code>1+q(n,m-1)</code>中划分结果：</p>
<ul>
<li>整数划分中包含<code>m</code>，则只有一种划分结果，即<code>&#123;m&#125;</code></li>
<li>整数划分中不包含<code>m</code>，则意味着划分中的最大整数位<code>m-1</code>，即需递归解决<code>q(n,m-1)</code></li>
</ul>
</li>
<li><p>当<code>n&gt;m</code>时，共有<code>q(n-m,m)+q(n,m-1)</code>中划分结果</p>
<ul>
<li>整数划分中包含<code>m</code>，即划分为<code>&#123;m,&#123;..&#125;</code>，这其中除了<code>m</code>外，其余部分可以看成对<code>n-m</code>继续进行划分，最大值可能为<code>m</code>,需递归解决<code>q(n-m,m)</code></li>
<li>整数划分中不包含<code>m</code>，即划分结果中最大为<code>m-1</code>，递归解决<code>q(n,m-1)</code></li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数划分问题（递归解法） https://developer.aliyun.com/article/445250</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 动态规划解法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">        <span class="comment">// 最大的划分不会超过n，所以等价于q(n, n)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">q</span>(n, n); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">        <span class="comment">// (1)划分中包含m，则划分就为&#123;m&#125;，只有一个数</span></span><br><span class="line">        <span class="comment">// (2)划分中不包含m，则划分中的最大数只能为m-1，即递归划分为q(n,m-1)个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">q</span>(n, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">        <span class="comment">// (1) 划分中包含m，即&#123;m, &#123;...&#125;&#125;, 其中除了m外，其余的看成对n-m继续进行划分，最大值可能为m, 即为q(n, m)</span></span><br><span class="line">        <span class="comment">// (2) 划分中不包含m，即划分中的所有数都要小于m，即看成为q(n,m-1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">q</span>(n - m, m) + <span class="built_in">q</span>(n, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">q</span>(n,m) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）动态规划解法</p>
<p>TODO</p>
<h2 id="2-5-棋盘覆盖问题"><a href="#2-5-棋盘覆盖问题" class="headerlink" title="2.5 棋盘覆盖问题"></a>2.5 棋盘覆盖问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320200745108.png" alt="image-20220320200745108"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320200807568.png" alt="image-20220320200807568"></p>
<p>思路：</p>
<ul>
<li><p>分治法将棋盘划分为四个区域，从而得到四个子问题进行解决。</p>
</li>
<li><p>特殊方格必然位于四个区域中的其中一个，但是另外三个区域则没有特殊方格，导致了子问题不相同。因此，可以假设先用一个L型骨牌放在四个区域的交界处当作特殊方格，从而使每一个区域内都存在一个特殊方格，如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220320201130769.png" alt="image-20220320201130769" style="zoom:50%;">
</li>
<li><p>通过这样的分割和假设，棋盘分割问题就可以转化为四个1&#x2F;4规模的子问题。</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//棋盘覆盖问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tile = <span class="number">0</span>;              <span class="comment">// L型骨牌的编号</span></span><br><span class="line"><span class="type">int</span> Board[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//存放棋盘</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> t = ++tile;   <span class="comment">//表示L型骨牌的编号</span></span><br><span class="line">    <span class="type">int</span> s = size / <span class="number">2</span>; <span class="comment">//划分区域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) <span class="comment">//如果特殊方格在左上区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr, tc, dr, dc, s); <span class="comment">//解决左上区域的子问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果特殊方格不在在左上区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr + s - <span class="number">1</span>][tc + s - <span class="number">1</span>] = t;             <span class="comment">//用L型骨牌在该区域右下角放置一个特殊方格</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr, tc, tr + s - <span class="number">1</span>, tc + s - <span class="number">1</span>, s); <span class="comment">//有特殊方格后则可以继续解决该子问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) <span class="comment">//如果特殊方格在右上区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr, tc + s, dr, dc, s); <span class="comment">//解决右上区域的子问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果特殊方格不在右上区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr + s - <span class="number">1</span>][tc + s] = t;                 <span class="comment">//用L型骨牌在该区域左下角放置一个特殊方格</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s); <span class="comment">//有特殊方格后则可以继续解决该子问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) <span class="comment">//如果特殊方格在左下区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr + s, tc, dr, dc, s); <span class="comment">//解决左下区域的子问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果特殊方格不在左下区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr + s][tc + s - <span class="number">1</span>] = t;                 <span class="comment">//用L型骨牌在该区域右上角放置一个特殊方格</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s); <span class="comment">//有特殊方格后则可以继续解决该子问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) <span class="comment">//如果特殊方格在右下区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr + s, tc + s, dr, dc, s); <span class="comment">//解决右下区域的子问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果特殊方格不在右下区域</span></span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr + s][tc + s] = t;                     <span class="comment">//用L型骨牌在该区域左上角放置一个特殊方格</span></span><br><span class="line">        <span class="built_in">ChessBoard</span>(tr + s, tc + s, tr + s, tc + s, s); <span class="comment">//有特殊方格后则可以继续解决该子问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> special_row = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> special_col = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ChessBoard</span>(<span class="number">0</span>, <span class="number">0</span>, special_row, special_col, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d &quot;</span>, Board[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-归并排序"><a href="#2-6-归并排序" class="headerlink" title="2.6 归并排序"></a>2.6 归并排序</h2><p>递归的解法：</p>
<ul>
<li>先对<code>nums[l:m]</code>进行排序，再对<code>nums[m+1:r]</code>进行排序。</li>
<li>将排好序的两部分合并，合并的时候先创建一个临时<code>tmp</code>，然后依次比较两部分的数值大小，将较小的放入<code>tmp</code>，然后移动指针；如果某一部分的元素已经全部放入，将另一部分剩余元素直接放入即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">P22</span></span><br><span class="line"><span class="comment">2.7 合并排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;  <span class="comment">//一定要初始化</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt; tmp;          // segmentation fault</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j已经全部放入，i还有剩余元素</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m) &#123;     </span><br><span class="line">        tmp[cnt++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i已经全部放入，i还有剩余元素</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) &#123;</span><br><span class="line">        tmp[cnt++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将[l:r]放回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i + l] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, l, m);      <span class="comment">// 对nums中的l到m进行排序</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, m + <span class="number">1</span>, r);  <span class="comment">// 对nums中的m+1到r进行排序</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, l, m, r);          <span class="comment">// [l:m]和[m+1:r]已经排好序，将他们进行合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">mergeSort</span>(a, <span class="number">0</span>, (<span class="type">int</span>)a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i:a)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-7-整数因子分解问题"><a href="#2-7-整数因子分解问题" class="headerlink" title="2.7 整数因子分解问题"></a>2.7 整数因子分解问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220323164805370.png" alt="image-20220323164805370"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: 1</span><br><span class="line">2: 2</span><br><span class="line">3: 3</span><br><span class="line">4: 4 2*2</span><br><span class="line">5: 5</span><br><span class="line">6: 6 2*3 3*2 </span><br></pre></td></tr></table></figure>

<p>（1）解法一：递归</p>
<p>思路：</p>
<ul>
<li>当<code>n=1</code>时，只有一种分解方式。</li>
<li>当<code>n&gt;1</code>时，<code>solve(n)</code>可以对<code>n</code>的每一个因子再去求该分解子问题。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">solve</span>(n/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">12</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3 动态规划"></a>3 动态规划</h1><h2 id="3-1-矩阵连乘问题"><a href="#3-1-矩阵连乘问题" class="headerlink" title="3.1 矩阵连乘问题"></a>3.1 矩阵连乘问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220407102052704.png" alt="image-20220407102052704"></p>
<p>（1）最优子结构</p>
<p>将$A_i A_{i+1} \dots A_j$的矩阵连乘定义为$A[i:j]$，那么现假设在位置$k$ 加括号使$A[i:j]&#x3D;A[i:k]A[k+1:j]$，那么总计算量就等于$A[i:k]$的计算量加上$A[k+1:j]$的计算量，再加上这矩阵相乘的计算量$p_{i-1}p_k p_j$。</p>
<p>并且，计算$A[i:j]$的最优次序所包含的计算矩阵子链$A[1:k]$和$A[k+1:j]$的次序也是最优的，即具有<strong>最优子结构性质</strong>。</p>
<p>反证：如果$k$不是最优的，即存在一个更好的划分位置$k’$使$A[1:k’]$或$A[k’+1:j]$的计算量更少，那么得到的$A[1:n]$计算量也会比最优次序的计算量更少，导致矛盾。</p>
<p>（2）建立递归关系</p>
<p>用$m[i][j]$存储$A[i][j]$的最优次序计算量，则原问题的最优值为$m[1][m]$。</p>
<ul>
<li>当$i&#x3D;j$时，只有一个矩阵，因此$m[i][j]&#x3D;0$</li>
<li>当$i&lt;j$时，假设在$k$断开，则$m[i][j]&#x3D;m[i][k]+m[k+1][j]+p_{i-1} p_k p_j$，由于$k$的位置不确定，因此这里需要取$min$。</li>
</ul>
<p>递归式如下：<br>$$<br>m[i][j]&#x3D; \begin{cases}0 &amp; i&#x3D;j \ \min <em>{i \leqslant k&lt;j}\left{m[i][k]+m[k+1][j]+p</em>{i-1} p_{k} p_{j}\right} &amp; i&lt;j\end{cases}<br>$$<br>除此之外，还可以顶一个$s[i][j]$用来存储最优断开位置$k$，在计算出最优值$m[i][j]$后，可递归地由$s[i][j]$构造出相应的最优解。</p>
<p>（3）构造最优解</p>
<p><code>s[i][j]</code>记录了<code>A[i:j]</code>最佳断开的位置<code>k</code>，因此当求解<code>A[1:n]</code>的最优加括号方式，只需要递归得查找<code>A[i:k]</code>和<code>A[k+1][j]</code>得最优加括号方式，即<code>A[1:s[1][n]]</code>和<code>A[s[1][n]+1:n]</code>。</p>
<p>（4）算法复杂度为$O(n^3)$</p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220524153317507.png" alt="image-20220524153317507" style="zoom:50%;">

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵连乘</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p0p1  p2p3 p4p5  p6p7 p8p9</span></span><br><span class="line"><span class="comment">//  A1    A2   A3    A4   A5</span></span><br><span class="line"><span class="comment">// n表示矩阵个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixChain</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;p, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">    &#123; <span class="comment">// 矩阵链的个数,从2个矩阵开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + r - <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">            <span class="comment">//遍历断开的位置k,找到最优次序(计算量最小)</span></span><br><span class="line">            m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j]; <span class="comment">//先假设在矩阵i后段断开</span></span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="comment">//从i+1出遍历断开位置k，找到最优次序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = i;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造最优解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Traceback</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Traceback</span>(i, s[i][j], s);</span><br><span class="line">    <span class="built_in">Traceback</span>(s[i][j] + <span class="number">1</span>, j, s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Multiply A &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s[i][j];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; and A&quot;</span> &lt;&lt; s[i][j] + <span class="number">1</span> &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p&#123;<span class="number">30</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">m</span>(<span class="number">12</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">12</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(<span class="number">12</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">12</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MatrixChain</span>(p, <span class="number">6</span>, m, s);</span><br><span class="line">    <span class="built_in">Traceback</span>(<span class="number">1</span>, <span class="number">6</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-最长公共子序列"><a href="#3-2-最长公共子序列" class="headerlink" title="3.2 最长公共子序列"></a>3.2 最长公共子序列</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220407140718590.png" alt="image-20220407140718590"></p>
<p>（1）最优子结构</p>
<p>设序列$X_m&#x3D;{x_1,x_2,\dots,x_m}$和$Y_n&#x3D;{y_1,y_2,\dots,y_n}$的最长公共子序列为$Z_k&#x3D;{z_1,z_2,\dots,z_k}$，可以从后往前看：</p>
<ul>
<li>如果$x_m&#x3D;y_n$，那么这个数一定在公共子序列中，即$z_k&#x3D;x_m&#x3D;y_n$，那么原问题的规模下降为求解$X_{m-1}$和$Y_{n-1}$的最长公共子序列$Z_{k-1}$</li>
<li>如果$x_m \neq y_n$且$z_k \neq x_m$，那么$x_m$一定不在公共子序列中，因此原问题规模可以下降为求解$X_{m-1}$和$Y_n$的最长公共子序列$Z_k$</li>
<li>如果$x_m \neq y_n$且$z_k \neq y_n$，那么$y_n$一定不在公共子序列中，因此原问题规模可以下降为求解$Y_{n-1}$和$X_m$的最长公共子序列$Z_k$</li>
</ul>
<p>反证：</p>
<ul>
<li>如果$z_k \neq x_m$，那么也就说明$z_k$后面还有一个公共数，即${z_1,z_2,\dots,z_k,x_m}$，那么此时公共子序列的长度为$k+1$，与$Z_k$是$X$和$Y$的最长公共子序列矛盾，因此必有$z_k&#x3D;x_m&#x3D;y_n$。同样的，如果$X_{m-1}$和$Y_{n-1}$有长度大于$k-1$的公共子序列$W$，那么将$x_m&#x3D;y_n$加在该序列末尾，会导致$X_m$和$Y_n$的最长公共子序列长度大于$k$，矛盾。因此，$Z_{k-1}$是$X_{m-1}$和$Y_{n-1}$的最长公共子序列。</li>
<li>因为$z_k \neq x_m$，$Z_k$是$X_{m-1}$和$Y$的公共子序列，若$X_{m-1}$和$Y$有长度大于$k$的公共子序列$W$，则$W$应该也是$X_m$和$Y_n$的公共子序列，与$Z_k$是$X_m$和$Y_n$最长公共子序列矛盾。</li>
</ul>
<p>因此，最长公共子序列问题包含了两个序列前缀的最长公共子序列的子问题，且具有最优子结构的性质。</p>
<p>（2）构造递归方程</p>
<ul>
<li>如果$x_m&#x3D;y_n$，那么这个数一定在公共子序列中，此时只需要找到$X_{m-1}$和$Y_{m-1}$的最长公共子序列，再在其末尾加上$x_m(x_m&#x3D;y_n)$即可。</li>
<li>如果$x_m \neq y_n$，那么就需要在$X_{m-1}$和$Y_n$以及$X_m$和$Y_{n-1}$两个最长公共子序列子问题中，找出更大的那个序列。</li>
</ul>
<p>递归方程如下，$c[i][j]$表示$X_i$与$Y_j$的最长公共子序列长度：<br>$$<br>c[i][j]&#x3D; \begin{cases}<br>0 &amp; i&gt;0 ; j&#x3D;0 \<br>c[i-1][j-1]+1 &amp; i, j&gt;0 ; x_{i}&#x3D;y_{i} \<br>\max {c[i][j-1], c[i-1][j]} &amp; i, j&gt;0 ; x_{i} \neq y_{i}\end{cases}<br>$$<br>（3）最优解</p>
<p>如果除了LCS的长度，还想获取具体的LCS序列，则还需要一个$b[i][j]$用来记录当前采取了哪种子问题，从而在构造LCS的时候，可以递归地进行打印。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  最长公共子序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最优值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LCSLength</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, string x, string y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;c, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果x和y中有一个序列长度为0, 则LCS长度为0</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x[i - <span class="number">1</span>] == y[j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                b[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c[i - <span class="number">1</span>][j] &gt; c[i][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                b[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                c[i][j] = c[i][j - <span class="number">1</span>];</span><br><span class="line">                b[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造最优解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LCS</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, string x, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (b[i][j] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LCS</span>(i - <span class="number">1</span>, j - <span class="number">1</span>, x, b);</span><br><span class="line">        cout &lt;&lt; x[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (b[i][j] == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LCS</span>(i - <span class="number">1</span>, j, x, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LCS</span>(i, j - <span class="number">1</span>, x, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// string x = &quot;programming&quot;;</span></span><br><span class="line">    <span class="comment">// string y = &quot;contest&quot;;</span></span><br><span class="line">    string x = <span class="string">&quot;abcfbc&quot;</span>;</span><br><span class="line">    string y = <span class="string">&quot;abfcab&quot;</span>;</span><br><span class="line">    <span class="type">int</span> m = x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = y.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">c</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">b</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LCSLength</span>(m, n, x, y, c, b);</span><br><span class="line">    cout &lt;&lt; c[m][n] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">LCS</span>(m, n, x, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-最大字段和"><a href="#3-3-最大字段和" class="headerlink" title="3.3 最大字段和"></a>3.3 最大字段和</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220410104055295.png" alt="image-20220410104055295"></p>
<p><strong>（1）分治法：</strong></p>
<ul>
<li><p>将原问题$a[1:n]$的最大子段和分解为$a[1:n&#x2F;2]$和$a[n&#x2F;2+1,n]$的两个子问题，分别求这两个子问题的最大子段和。</p>
</li>
<li><p>在这两个子问题进行合并的时候，会存在以下三种情况：</p>
<ul>
<li>$a[1:n]$的最大子段和与子问题$a[1:n&#x2F;2]$的最大子段和相同。</li>
<li>$a[1:n]$的最大子段和与子问题$a[n&#x2F;2+1:n]$的最大子段和相同。</li>
<li>$a[1:n]$的最大子段和$\sum_{k&#x3D;i}^j{a_k}$的开始位置$i&lt;n&#x2F;2$，结束位置$j&gt;n&#x2F;2+1$。</li>
</ul>
</li>
<li><p>对于前两种情况，直接递归求解即可。对于第三种情况，$a[n&#x2F;2]$和$a[n&#x2F;2+1]$肯定在最优子段中，那么只需从位置$n&#x2F;2$分别向前、向后找到最大的子段，也就是<br>$$<br>最大子段和&#x3D;\max_{1 \leq i \leq n&#x2F;2} \sum_{k&#x3D;i}^{n&#x2F;2}a[k]  + \max_{n&#x2F;2+1 \leq i \leq n} \sum_{k&#x3D;n&#x2F;2+1}^{j}a[k]<br>$$</p>
</li>
<li><p>复杂度分析：子问题规模为$n&#x2F;2$,合并需要$O(n)$，递归式如下，解得$T(n)&#x3D;O(n\log{n})$<br>$$<br>T(n) &#x3D;<br>\begin{cases}<br>O(1) &amp; n \leq c \<br>2T(n&#x2F;2) + O(n) &amp; n \gt c </p>
<p>\end{cases}<br>$$</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大子段和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 分治法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当所有整数为负整数时定义最大子段和为0</span></span><br><span class="line">    <span class="keyword">if</span> (left == right)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = a[left] &gt; <span class="number">0</span> ? a[left] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> leftSubSum = <span class="built_in">MaxSubSum</span>(a, left, mid);</span><br><span class="line">        <span class="type">int</span> rightSubSum = <span class="built_in">MaxSubSum</span>(a, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在左边找到最大的子段</span></span><br><span class="line">        <span class="type">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &gt;= left; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            leftSum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftSum &gt; s1)</span><br><span class="line">        &#123;</span><br><span class="line">            s1 = leftSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在左边找到最大的子段</span></span><br><span class="line">        <span class="type">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            rightSum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightSum &gt; s2)</span><br><span class="line">        &#123;</span><br><span class="line">            s1 = rightSum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = leftSum + rightSum;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; leftSum)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = leftSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; rightSum)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = rightSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a[1:n]的最大子段和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MaxSubSum</span>(a, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">-2</span>, <span class="number">11</span>, <span class="number">-4</span>, <span class="number">13</span>, <span class="number">-5</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">maxSum</span>(<span class="number">6</span>, a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;res:&quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）动态规划</strong></p>
<p>设$b[i-1]$表示$a[1:i-1]$的最大子段和，那么对于第$i$个元素$a[i]$来说，它要么合并到$a[1:i-1]$的最大子段中，要么重新成为一个新的子段，取决于$b[i-1]+a[i]$和$a[i]$的大小。</p>
<p>因此，动态规划的递归式如下：<br>$$<br>b[i] &#x3D; \max { b[i-1] + a[i], a[i]},\space 1 \leq i \leq n<br>$$<br>该方法只需要遍历一次序列，复杂度为$O(n)$</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大子段和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> prev = <span class="number">0</span>, maxSum = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> x:a)</span><br><span class="line">    &#123;</span><br><span class="line">        prev = <span class="built_in">max</span>(prev + x, x);</span><br><span class="line">        maxSum = <span class="built_in">max</span>(prev, maxSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">-2</span>, <span class="number">11</span>, <span class="number">-4</span>, <span class="number">13</span>, <span class="number">-5</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">maxSum</span>(<span class="number">6</span>, a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;res:&quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划的遍历方式通常是以序列的结束节点为基准，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220410111715319.png" alt="image-20220410111715319"></p>
<h2 id="3-4-凸多边形最优三角剖分"><a href="#3-4-凸多边形最优三角剖分" class="headerlink" title="3.4 凸多边形最优三角剖分"></a>3.4 凸多边形最优三角剖分</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220410135646280.png" alt="image-20220410135646280"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220410135702182.png" alt="image-20220410135702182"></p>
<p><strong>思路：</strong></p>
<ul>
<li><p>本质上与矩阵连乘问题类似，定义$t[i][j](1 \leq i \lt j \leq n)$ 为凸多边形 ${v_{i-1},v_i,\dots,v_j }$ 的最优三角剖分对应的权函数值。因此，原问题计算凸$n+1$边形的最优权值为$t[1][n] ({v_0,v_1,\dots,v_n})$。</p>
</li>
<li><p>若只有两条边，定义权值为零，即$t[i][i]&#x3D;0(i&#x3D;1,2,\dots,n)$。</p>
</li>
<li><p>当至少有三个顶点时($j-i\ge 1$)时，以$v_{i-1}v_j$的弦底边，某一个点$v_k$为顶点，将凸多边形划分成了${v_{i-1},v_{i}\dots,v_k}$和${v_{k},v_{k+1},\dots,v_j}$两个凸多边形，以及一个三角形${v_{i-1},v_k,v_j}$，这两个划分出来的凸多边形构成了子问题$t[i][k]$和$t[k+1][j]$，且具有最优子结构性质。</p>
</li>
<li><p>因此，原问题$t[i][j]$就等于了$t[i][k]+t[k+1][j]$再加上三角形的权值$w(v_{i-1} v_k v_j)$。而现在不确定最优划分的$v_k$的位置，所以$t[i][j]$的递归式定义如下，时间复杂度为$O(n^3)$：<br>$$<br>t[i][j]&#x3D; \begin{cases}0 &amp; i&#x3D;j \ \min <em>{i \leqslant k \leqslant j}\left{t[i][k]+t[k+1][j]+w\left(v</em>{i-1} v_{k} v_{j}\right)\right} &amp; i&lt;j\end{cases}<br>$$</p>
</li>
<li><p>若想构造最优三角剖分，还需要定一个数组$s[i][j]$用于记录$v_k$的顶点位置，时间复杂度为$O(n)$</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MinWeightTriangulation</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;t, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) &#123; <span class="comment">//只有两个顶点</span></span><br><span class="line">        t[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">2</span>; r &lt;= n; r++) &#123;  /</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - r + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + r - <span class="number">1</span>; </span><br><span class="line">            t[i][j] = t[i + <span class="number">1</span>][j] + <span class="built_in">w</span>(i - <span class="number">1</span>, i, j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; i + r - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                <span class="type">int</span> u = t[i][k] + t[k + <span class="number">1</span>][j] + <span class="built_in">w</span>(i - <span class="number">1</span>, k, j);</span><br><span class="line">                <span class="keyword">if</span> (u &lt; t[i][j]) &#123;</span><br><span class="line">                    t[i][j] = u;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-多边形游戏"><a href="#3-5-多边形游戏" class="headerlink" title="3.5 多边形游戏"></a>3.5 多边形游戏</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220412203445335.png" alt="image-20220412203445335"></p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220412203508963.png" alt="image-20220412203508963" style="zoom:40%;">

<p>书上讲的挺清楚，直接放上来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220412204800514.png" alt="image-20220412204800514"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220412204813897.png" alt="image-20220412204813897"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220412204825130.png" alt="image-20220412204825130"></p>
<h2 id="3-6-图像压缩"><a href="#3-6-图像压缩" class="headerlink" title="3.6 图像压缩"></a>3.6 图像压缩</h2><p>在计算机中，常用像素点的灰度值序列${p_1,p_2,\dots, p_n}$表示图像。其中整数$p_i(1 \leq i \leq n)$，表示像素点$i$的灰度值($0 \sim 255$)，因此最多需要8位表示一个像素。</p>
<p>图像压缩就是将像素点序列${p_1,p_2,\dots, p_n}$分割成$m$个连续段$S_1,S_2,\dots,S_m$。</p>
<ul>
<li><p>其中$S_i$中有$l[i]$个像素，且该段中每个像素都只用$b[i]$位表示，也就是“要表示该段中最大的数字需要的位数”，这样每一个像素段就可以用$l[i]*b[i]$位来存储。</p>
</li>
<li><p>除此之外，还需要用一定的存储空间来表示每一段的$b[i]$和$l[i]$的值，$b[i]$最大为8，也就是需要3位来表示，如果限制$l[i]$的最大值位256，那么就需要8位来表示。</p>
</li>
<li><p>因此，每一段子序列$S_i$所需要的存储空间就为$l[i]*b[i]+11$，总共需要的存储空间为$\sum_{i&#x3D;1}^{m}l[i]<em>b[i]+11</em>m$</p>
</li>
</ul>
<p>现在图像压缩问题，就是确定像素序列${p_1,p_2,\dots, p_n}$的最优分段，使得依此分段所需的存储空间最小。其中，$0 \leq p_i \leq 256, \space 1 \leq i \leq n$，每个分段长度不超过256位。</p>
<p>（1）最优子结构(?)</p>
<p>假设$l[i]$和$b[i]$($1 \leq i \leq m$)是${p_1,p_2,\dots,p_n}$的一个最优分段。显然$l[1]、b[1]$是${p_1,\dots,p_{l[1]}}$的一个最优分段，且$l[i]$和$b[i]$($2 \leq i \leq m$ )是${p_{l[1]+1},\dots,p_n }$的一个最优分段，即满足最优子结构性质。</p>
<p>（2）递归计算最优值</p>
<p>设$s[i]$($1 \leq i \leq n$)是像素序列${p_1,p_2,\dots,p_i}$的最优分段所需要的存储位数，以下面这个例子说明：</p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220413115012969.png" alt="image-20220413115012969"></p>
<ul>
<li>$s[0]$：当没有像素的时候肯定为0，也就是$s[0]&#x3D;0$</li>
<li>$s[1]$：当像素序列长度为1时，直接用该段所需的最大存储位(上例位3)，再加上用于存储b和l的11</li>
<li>$s[2]$：当像素序列长度大于2时，就考虑在哪里进行分段，并取下面这些情况的最小值：<ul>
<li>不分段，即将这2个像素看成一段，那么还是用该段所需的最大存储位数(3)乘上该段的像素数量(2)，再加上11。</li>
<li>从$p_1$后面分段，前面一段的最优存储空间直接用$s[1]$表示；第二段用该段所需的最小存储位数(3)乘上该段的像素数量(1)，再加上11。</li>
</ul>
</li>
<li>$s[3]$：当计算序列长度为3的最优存储空间，依然是寻找在哪里进行分段，此时有三种情况，取其中的最小值：<ul>
<li>不分段，将前3个像素看成一段，就是直接用该段所需的最大存储位数(3)乘上该段的像素数量(3)，再加上11。</li>
<li>从$p_1$后面分段，前面一段的最优存储空间直接用$s[1]$表示；第二段用该段所需的最大存储位数(3)乘上该段的像素数量(2)，再加上11。</li>
<li>从$p_2$后面分段，前面一段的最优存储空间直接用$s[2]$表示；第二段用该段所需的最大存储位数(3)乘上该段的像素数量(1)，再加上11。</li>
</ul>
</li>
<li>以此类推，知道计算出$s[n]$即为$p_1,\dots,p_n$的最优分段所需的存储空间。</li>
</ul>
<p>因此，递归式为：<br>$$<br>\begin{gathered}<br>s[i]&#x3D;\min _{1 \leqslant k \leqslant \min {i, 256}}{s[i-k]+k * b \max (i-k+1, i)}+11 \<br> \operatorname{bmax}(i, j)&#x3D;\left[\log \left(\max <em>{i \leqslant k \leqslant j}\left{p</em>{k}\right}+1\right)\right]<br>\end{gathered}<br>$$<br>上式中$bmax(i,j)$就是为了找到${p_i,\dots,p_j}$段中所需要的存储位数。</p>
<p>（3）代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Compress</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p[], <span class="type">int</span> s[], <span class="type">int</span> l[], <span class="type">int</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Lmax = <span class="number">256</span>, header = <span class="number">11</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = <span class="built_in">binaryLen</span>(p[i]);</span><br><span class="line">        <span class="type">int</span> bmax = b[i];</span><br><span class="line">        <span class="comment">// 在p_&#123;i-1&#125;处分段，前一段直接为s[i-1],后一段即为p_i的二进制表示位数bmax</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + bmax;</span><br><span class="line">        l[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 因此向前遍历分段的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= i &amp;&amp; j &lt;= Lmax; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bmax &lt; b[i - j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                bmax = b[i - j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若在p_j处分段，前一段存储空间为s[i-j]，后一段为其中的最大表示位数bmax，乘上后一段的像素数量j</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt; s[i - j] + j * bmax)</span><br><span class="line">            &#123;</span><br><span class="line">                s[i] = s[i - j] + j * bmax;</span><br><span class="line">                l[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] += header;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用二进制表示i所需的位数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binaryLen</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    i = i / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        i = i / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-流水作业调度"><a href="#3-7-流水作业调度" class="headerlink" title="3.7 流水作业调度"></a>3.7 流水作业调度</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220525105706342.png" alt="image-20220525105706342"></p>
<p>完成集合 $S$ 中作业所需的最短时间为 $T(S,t)$，表示机器 $M_1$ 开始加工 $S$ 中作业时，机器 $M_2$ 还需要等待 $t$ 时间后才可用，因此原问题的最优值为 $T(N,0)$。</p>
<p><strong>（1）最优子结构</strong></p>
<p>设原问题 $N &#x3D; {1,2,\dots,n}$ 的最优调度为 $\pi$ （即$n$个作业的一个排列），所需加工时间为 $a_{\pi(1)}+T(S,b_{\pi(1)})$，其中子问题 $S&#x3D;N-{\pi(1)}$。若 $S$ 存在更优的调度 $T’(S,b_{\pi(1)})$，即  $T’(S,b_{\pi(1)})&lt; T(S,b_{\pi(1)})$，那么可以得到$a_{\pi(1)}+T’(S,b_{\pi(1)}) &lt; a_{\pi(1)}+T(S,b_{\pi(1)})$，与 $\pi$ 是原问题的最优解矛盾，所以该问题满足最优子结构形式。</p>
<p><strong>（2）构造递归方程</strong></p>
<p>当$T(S,t)$加工第 $i$ 个作业时，$M_1$ 上需要需要时间 $a_i$， $M_2$ 开始加工第 $i$ 个作业前，需要等待 $\max {t,a_i}-a_i&#x3D;\max {t-a_i, 0}$ 个时间，然后再需要$b_i$ 时间完成作业 $i$ 的加工，因此递归方程如下：<br>$$<br>T(S,t) &#x3D; \min_{i \in S} {a_i+T(S-{i},b_i + \max{t-a_i,0})}<br>$$<br><strong>（3）基于 Johnson 法则的流水调度算法</strong></p>
<p>流水调度问题一定存在满足 Johnson 法则的最优调度，算法如下：</p>
<ul>
<li><p>令 $N_1&#x3D;{i|a_i &lt; b_i}$，$N_2 &#x3D; {i| a_i \geq b_i}$</p>
</li>
<li><p>将 $N_1$ 中的作业依 $a_i$ 非减序排列，将 $N_2$ 中的作业依 $b_i$ 非增序排列。</p>
<ul>
<li>$M_2$ 上任务等待的时间越少越好 &#x3D;&gt; 在 $M_1$ 上加工时间短的排前面，在 $M_2$加工时间长的排在前面。</li>
</ul>
</li>
<li><p>$N_1$中作业接 $N_2$ 中作业构成满足 Johnson 法则的最优调度</p>
</li>
<li><p>算法复杂度为 $O(nlogn)$</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220524205234433.png" alt="image-20220524205234433" style="zoom:50%;">

<img src="/.site//image-20220524205909299.png" alt="image-20220524205909299" style="zoom:50%;">

<h2 id="3-8-0-1背包问题"><a href="#3-8-0-1背包问题" class="headerlink" title="3.8 0-1背包问题"></a>3.8 0-1背包问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220525105722224.png" alt="image-20220525105722224"></p>
<p><strong>（1）最优子结构</strong></p>
<p>设 $(y_1,y_2,\dots,y_n)$ 是原问题 $\max \sum_{i&#x3D;1}^{n}v_i x_i, \sum_{i&#x3D;1}^{n}w_ix_i \leq c$的最优解，则 $(y_2,\dots,y_n)$其子问题为 $\max \sum_{i&#x3D;2}^{n}v_i x_i, \sum_{i&#x3D;2}^{n}w_ix_i \leq c-w_1y_1$。否则，若子问题存在一个更优的解 $(z_2,\dots,z_n)$，即 $\sum_{i&#x3D;2}^{n}v_i z_i \gt \sum_{i&#x3D;2}^{n}v_i y_i$，那么可以得到 $v_1 y_1 + \sum_{i&#x3D;2}^{n}v_i z_i \gt v_1 y_1 +  \sum_{i&#x3D;2}^{n}v_i y_i$，与 $(y_1,y_2,\dots,y_n)$ 是原问题的最优解矛盾，所以该问题满足最优子结构性质。</p>
<p><strong>（2）构造递归方程</strong></p>
<p>该问题的最优值为 $m(i,j)$ 表示背包容量为 $j$，可选择物品为 $i,i+1,\dots,n$ 时的0-1背包问题最优值，其递归式如下：<br>$$<br>\begin{gathered}<br>m(i, j)&#x3D; \begin{cases}\max \left{m(i+1, j), m\left(i+1, j-w_{i}\right)+v_{i}\right} &amp; j \geqslant w_{i} \<br>m(i+1, j) &amp; 0 \leqslant j&lt;w_{i}\end{cases} \<br>m(n, j)&#x3D; \begin{cases}v_{n} &amp; j \geqslant w_{n} \<br>0 &amp; 0 \leqslant j&lt;w_{n}\end{cases}<br>\end{gathered}<br>$$<br><strong>（3）计算复杂性分析</strong></p>
<p>该递归式需要 $O(nc)$ 的计算时间（算法相当于填一个二维表，行列分别是物品数量和背包最大容量）</p>
<p><strong>（4）算法的改进</strong></p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220524220108676.png" alt="image-20220524220108676" style="zoom:50%;">

<p>改进后的算法复杂性为 $O(2^n)$</p>
<h1 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4 贪心算法"></a>4 贪心算法</h1><p>证明贪心选择策略</p>
<h2 id="4-1-活动安排问题"><a href="#4-1-活动安排问题" class="headerlink" title="4.1 活动安排问题"></a>4.1 活动安排问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220418134358292.png" alt="image-20220418134358292"></p>
<p><strong>（1）贪心选择策略</strong></p>
<p>每次将结束时间最早的活动优先安排，即留下尽可能多的时间给其他活动。</p>
<p>具体做法为，按活动的结束时间非减序排列，然后在安排完第一个活动后，以此判断后续活动是否与前一个安排的活动结束时间相容，相容则安排，不相容则不安排。</p>
<p><strong>证明：</strong>设原问题 $E&#x3D;{1,2,\dots,n}$ 为所给活动集合，其中活动按结束时间非减序排列，即活动1具有最早完成时间。设该问题的的最优解为 $A$，且 $A$ 中的活动按结束时间 $f_i$ 非减序排列，$A$ 中第一个活动是活动 $k$。</p>
<ul>
<li>若 $k&#x3D;1$，则 $A$ 为一个以贪心选择开始的最优解。</li>
<li>若 $k \gt 1$，则设 $B&#x3D;A - {k} \cup {1} $，（即用第1个活动替换第k个活动）因为 $f_1 \leq f_k$ 且 $A$ 中的活动是相容的，所以 $B$ 中的活动也是相容的。又因为 $|B|&#x3D;|A|$，且 $A$ 是最优的，所以 $B$ 也是最优的，也就是说 $B$ 是以贪心选择活动 1 开始的最优活安排。</li>
<li>综上，从存在以该贪心选择开始的最优活动安排方案。</li>
</ul>
<p><strong>（2）最优子结构</strong></p>
<p>设子问题 $E’&#x3D; {i \in E: s_i \geq f_1}$，若 $A$ 是原问题 $E$ 的最优解， 则 $A’&#x3D;A-{1}$ 是子问题 $E’$ 的最优解。若$E’$ 存在更优的一个解 $A’’$，即 $A’’ &lt; A’$，那么有 $A’’ \cap {1}&lt;A’ \cap {1}&#x3D;A$，与 $A$ 是原问题的最优解矛盾，所以该问题满足最优子结构性质。</p>
<p><strong>（3）复杂度分析</strong></p>
<p>按结束时间排序活动需要$O(n logn)$，按贪心算法安排活动需要$O(n)$，总共需要 $O(n long)$</p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165341653.png" alt="image-20220620165341653" style="zoom:50%;">

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设已经按结束时间非减序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="comment">//用集合A[i]=true表示安排的活动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="type">int</span> n, Type s[], Type f[], <span class="type">bool</span> A[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 降低一个活动加入集合A</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; f[j]) <span class="comment">//如果第i个活动与上一个安排的活动相容</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = <span class="literal">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-2-背包问题"><a href="#4-2-背包问题" class="headerlink" title="4.2 背包问题"></a>4.2 背包问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220418141319971.png" alt="image-20220418141319971"></p>
<ul>
<li><p>与0-1背包问题的区别是，背包问题可以选择物体的一部分装入背包，因此可以使用贪心算法。</p>
</li>
<li><p><strong>贪心策略是每次优先将单位重量价值高的物品装入背包内。</strong></p>
</li>
<li><p>0-1背包由于每个物品只能选择装入或者不装入，如果使用贪心策略可能会导致背包容量的浪费，从而总价值达不到最优。</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 背包问题</span></span><br><span class="line"><span class="comment">// 贪心策略: 优先将单位价值高的物品装入背包内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照单位价值(v/w)对物品进行排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> v[], <span class="type">float</span> w[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Knapsack</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> M, <span class="type">float</span> v[], <span class="type">float</span> w[], <span class="type">float</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sort</span>(n, v, w); <span class="comment">//按单位价值排序</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化背包</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> c = M;    <span class="comment">//背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前的重量已大于背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        x[i] = <span class="number">1</span>;   <span class="comment">// 在有容量的情况下尽可能将单位价值高的全装入</span></span><br><span class="line">        c -= w[i];  <span class="comment">//  更新背包剩余容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当还有剩余物品，但背包容量不足以放下完整的物品, 放入一部分</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= n)</span><br><span class="line">        x[i] = c / w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-最优装载"><a href="#4-3-最优装载" class="headerlink" title="4.3 最优装载"></a>4.3 最优装载</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220418143231291.png" alt="image-20220418143231291"></p>
<p><strong>（1）贪心选择策略</strong></p>
<p>重量最轻的优先进行装载。</p>
<p>证明：设集装箱按照其重量非减序排列， $(x_1,x_2,\dots,x_n)$ 是原问题的一个最优解，设 $k&#x3D; \min_{1 \leq i \leq n} {i|x_i&#x3D;1}$，（第一个装入的集装箱为k），如果原问题有解，则 $1\leq k \leq n$。</p>
<ul>
<li>当 $k&#x3D;1$ 时，$(x_1,x_2,\dots,x_n)$ 是满足贪心选择性质的一个最优解。</li>
<li>当 $k \gt 1$ 时，取另一个解$(y_1,y_2,\dots,y_n)$ ，其中 $y_1&#x3D;1,y_k&#x3D;0,y_i&#x3D;x_i,1 \lt i \leq n,i \neq k$，（也就是用第1个箱子替换掉原来装入的第k个箱子），又因为 $w_1 \leq w_k$，所以有 $\sum_{i&#x3D;1}^{n}w_iy_i&#x3D;\sum_{i&#x3D;1}^{n}w_ix_i-w_k+w_1 \leq \sum_{i&#x3D;1}^{n}w_ix_i \leq c$，即 $(y_1,y_2,\dots,y_n)$ 是装载问题的可行解，且 $\sum_{i&#x3D;1}^{n}y_i&#x3D;\sum_{i&#x3D;1}^{n}x_i$，即$(y_1,y_2,\dots,y_n)$ 是满足贪心选择性质的最优解。</li>
<li>所以，装载问题具有贪心选择性质。</li>
</ul>
<p><strong>（2）最优子结构性质</strong></p>
<p>设 $A&#x3D;{x_1,x_2,\dots,x_n}$ 是原问题 $n$ 个集装箱 $E$ 的最优解，则 $A’&#x3D;(x_2,x_3,\dots,x_n)$ 是子问题 $x_1&#x3D;1$，轮船载重量$c-w_1$ 的子问题的最优解。若存在子问题更优的一个解 $A’’$，使得 $\sum_{x \in A’’} x_i \lt \sum_{x \in A’} x_i$，则可以得到 $x_1 + \sum_{x \in A’’} x_i \lt x_1 + \sum_{x \in A’} x_i &#x3D; \sum_{x \in A} x_i$，与 $A$ 是原问题的最优解矛盾。因此，装载问题具有最优子结构性质。</p>
<p><strong>（3）算法复杂度</strong></p>
<p>重要复杂度来自于对集装箱重量的排序，即 $O(n \log{n})$。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对物品按照重量非减序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(<span class="type">float</span> w[], <span class="type">int</span> t[], <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loading</span><span class="params">(<span class="type">int</span> x[], <span class="type">float</span> w[], <span class="type">float</span> c, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *t = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 用t存放排好序后的物品编号</span></span><br><span class="line">    <span class="built_in">Sort</span>(w, t, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; w[t[i]] &lt;= c; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[t[i]] = <span class="number">1</span>;</span><br><span class="line">        c -= w[t[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-4-哈夫曼编码"><a href="#4-4-哈夫曼编码" class="headerlink" title="4.4 哈夫曼编码"></a>4.4 哈夫曼编码</h2><p>贪心选择性质：每次选择频率最小的两棵子树进行合并，从而产生一棵新的子树，其频率为合并的两棵子树频率之和。n 个字符的哈夫曼算法复杂度为 $O(n \log{n})$。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165512635.png" alt="image-20220620165512635"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165519629.png" alt="image-20220620165519629"></p>
<p>哈夫曼编码的实例，频率小的字符深度大：</p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165537701.png" alt="image-20220620165537701" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165545647.png" alt="image-20220620165545647" style="zoom:50%;">

<h2 id="4-5-单源最短路径"><a href="#4-5-单源最短路径" class="headerlink" title="4.5 单源最短路径"></a>4.5 单源最短路径</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220525175135119.png" alt="image-20220525175135119"></p>
<p>最优子结构性质：一个最短路径的子路径也是最短路径</p>
<p>算法基本思想——贪心：</p>
<ul>
<li>维护一个顶点集合 $S$，它们从原点 $s$ 的最短路径已知</li>
<li>每一步添加 𝑣 ∈ 𝑉 − 𝑆 中具有最小距离的顶点到 S 中</li>
<li>更新剩余顶点 v 的距离估计</li>
</ul>
<p>Dijkstra算法（边权重非负，如果权重可能为负则采用Bellman-Ford算法）：</p>
<ul>
<li>初始时，S中仅含有源</li>
<li>设 v 是 G 的某一个顶点，把从源到 v 且中间只经过 S 中顶点的路 称为从源到 v 的特殊路径，并用数组 dist 记录当前每个顶点所对 应的最短特殊路径长度 </li>
<li>每次从 V-S 中取出具有最短特殊路长度的顶点 v，将 v 添加到 S 中 ，同时对数组 dist 作必要的修改 </li>
<li>一旦 S 包含了所有 V 中顶点，dist 就记录了从源到所有其它顶点 之间的最短路径长度</li>
<li>对于具有 $n$ 个顶点和 $e$ 条边的带权有向图，主循环需要 $O(n)$，循环执行 n-1次，所以复杂度为 $O(n^2)$。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165649508.png" alt="image-20220620165649508" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165654992.png" alt="image-20220620165654992" style="zoom:50%;">

<p>Dijkstra算法的贪心选择策略是从 V - S 中选择具有最短特殊路径的顶点 u，从而确定从源到 u 的最短路径长度 dist[u]。</p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165706534.png" alt="image-20220620165706534"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165716917.png" alt="image-20220620165716917"></p>
<h2 id="4-6-最小生成树"><a href="#4-6-最小生成树" class="headerlink" title="4.6 最小生成树"></a>4.6 最小生成树</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165734836.png" alt="image-20220620165734836"></p>
<p><strong>（1）Prim 算法</strong>（选边）</p>
<p>设 $G&#x3D;(V,E)$ 是连通带权图，$V&#x3D;{1,2,\dots,n}$。构造 $G$ 的最小生成树的 Prim算法基本思想是： 首先设置 $S&#x3D;{1}$，然后只要 $S$ 是 $V$ 的真子集，就做如下贪心选择：选取满足条件 $i \in S$，$j \in V-S$，且 $c[i][j]$ 最小的边，并将顶点 $j$ 添加到 $S$ 中。这个过程一直进行直到 $S&#x3D;V$ 时为止，选取到的所有边恰好构成 $G$ 的一颗最小生成树。</p>
<p>贪心选择性质证明：上述算法中的边集合 T 始终包含 G 的某棵最小生成树中的边 (循环不变式)。因此，在算法结束时，T 中的所有边构成 G 的 一棵最小生成树</p>
<p>Prim 算法的时间复杂度为 $O(n^2)$。</p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165744181.png" alt="image-20220620165744181" style="zoom:50%;">

<p><strong>（2）Kruskal 算法</strong></p>
<p>Kruskal算法构造 G 的最小生成树的基本思想：</p>
<ul>
<li>首先将 G 的 n 个顶点看成 n 个孤立的连通分支，将所有的边按权从小到大排序</li>
<li>从第一条边开始，依<strong>边权递增</strong>的顺序查看每一条边，并按下述方法连接 2 个不同的连通分支：<ul>
<li>当查看到第 $k$ 条边 $(v,w)$ 时，如果端点 $v$ 和 $w$ 分别是当前 2 个不同的连通分支 $T_1$ 和 $T_2$ 中的顶点时，就用边 $(v,w)$ 将 $T_1$ 和 $T_2$  连接成一个连通分支，然后继续查看第 $k+1$ 条边</li>
<li>如果端点 $v$ 和 $w$ 在当前的同一个连通分支中，就直接再查看第 $k+1$ 条边</li>
</ul>
</li>
<li>这个过程一直进行到只剩下一个连通分支时为止</li>
<li>当图的顶点数为 $n$，边数为 $e$ 时，Kruskal算法所需的计算时间是 $O(e \log{e})$</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220525204151155.png" alt="image-20220525204151155" style="zoom: 43%;">

<h2 id="4-7-多机调度问题"><a href="#4-7-多机调度问题" class="headerlink" title="4.7 多机调度问题"></a>4.7 多机调度问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220525210600671.png" alt="image-20220525210600671"></p>
<p>这个问题是 NP完全问题，到目前为止还没有有效的解法， 对于这一类问题，用贪心选择策略<strong>有时</strong>可以设计出较好的近似算法。</p>
<p>贪心策略：<strong>最长处理时间作业优先。</strong></p>
<ul>
<li>当 $n \leq m$ 时，只要将机器 $i$ 的 $[0, t_i]$ 时间区间分配给作业 $i$ 即可，算法只需要 $O(1)$ 时间</li>
<li>当 $n \gt m$ 时，首先将 $n$ 个作业依其所需的<strong>处理时间从大到小排序</strong>；然后依此顺序将作业分配给空闲的机器处理。</li>
<li>算法所需的时间复杂度为 $O(n \log{n})$</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220525211248692.png" alt="image-20220525211248692" style="zoom: 50%;">



<h2 id="4-7-会场安排问题"><a href="#4-7-会场安排问题" class="headerlink" title="4.7 会场安排问题"></a>4.7 会场安排问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220419142222514.png" alt="image-20220419142222514"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220419142240458.png" alt="image-20220419142240458"></p>
<p><strong>（1）贪心策略：</strong></p>
<p>在满足与前一个活动相容的情况下，优先选择开始时间早的活动。</p>
<p><strong>（2）最优子结构</strong></p>
<p>设原问题为$E$的最优解为$A$，现在假设活动1为会场1中安排的第一个活动。那么，可以得到与活动1相容的子问题$E’&#x3D;E-{1}$，现在需要证明$A’&#x3D;A-{1}$是$E’$的最优解。</p>
<p>反证：假设存在子问题$E’&#x3D;E-{1}$的一个最优解为$A’’$，那么有$|A’’|&lt;|A’|$，即$|A’’ \cup {1}|&lt;|A’ \cup {1}|&#x3D;|A|$，与$A$是原问题$E$的最优解矛盾。</p>
<p><strong>（3） 贪心选择性质</strong></p>
<p>现在假设最优解$E$，按照活动的开始时间非减序排列${s_1,s_2,\dots,s_n}$，对应的结束时间为${f_1,f_2,\dots,f_n}$。</p>
<p>设在满足会场1相容条件(即开始时间大于会场1前一个活动结束时间)的前提下，第一个安排到会场1中的活动为$a_1$，而开始时间最早的活动为$a_k$。</p>
<ul>
<li>若 $k&#x3D;1$，即为满足贪心选择性质的最优解。</li>
<li>若$k \neq 1$，因为$s_k&lt;s_1$，所以它们一定不会安排在同一个会场。假设活动$a_k$安排在第$m$个会场，会场$m$前一个活动为$a_x$，即有$s_k \geq f_x $。现在将$a_1$与$a_k$的会场进行互换得到解$E’$，因为$a_1$与$a_k$均满足会场1的相同条件，且$s_1 \gt s_k \geq f_x$，即$a_1$也满足会场$m$的相容条件，所以$E’$为该问题的一个可行解。又因为$|E’|&#x3D;|E|$，所以$E’$是满足贪心选择性质的最优解。</li>
</ul>
<p><strong>（4）代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Xiaojian Yuan</span></span><br><span class="line"><span class="comment"> * @Date: 2022-04-18 18:17:43</span></span><br><span class="line"><span class="comment"> * @Description: 会场安排问题</span></span><br><span class="line"><span class="comment"> * 贪心策略: 每次选择开始时间早的，看看是否可以安排在某个相容的会场中</span></span><br><span class="line"><span class="comment"> * @FilePath: /cpp/algorithm/algorithm_homework/4-1/4-1.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125; activity[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.begin &lt; b.begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; activity[i].begin &gt;&gt; activity[i].end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按活动的开始时间排序</span></span><br><span class="line">    <span class="built_in">sort</span>(activity, activity + k, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储会场数量</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 存储每个会场中活动的结束时间</span></span><br><span class="line">    <span class="type">int</span> room[maxn];</span><br><span class="line">    room[<span class="number">1</span>] = activity[<span class="number">0</span>].end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次遍历每个活动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 依次遍历目前已开辟的会场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= res; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断是否存在相容的会场</span></span><br><span class="line">            <span class="keyword">if</span> (activity[i].begin &gt;= room[j])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 存在相容的会场, 更新该会场的结束时间</span></span><br><span class="line">                room[j] = activity[i].end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前没有相容的会场,则开辟一个新会场</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            room[res] = activity[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-8-最优合并问题"><a href="#4-8-最优合并问题" class="headerlink" title="4.8 最优合并问题"></a>4.8 最优合并问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220419142657696.png" alt="image-20220419142657696"></p>
<p><strong>（1）贪心策略</strong></p>
<ul>
<li>最优合并策略：优先序列长度最小的两个序列进行合并。</li>
<li>最差合并策略：优先序列长度最大的两个序列进行合并。</li>
</ul>
<p><strong>（2）贪心选择策略</strong></p>
<p>与哈夫曼编码问题等价，设$S$为要合并的序列集合，其中$S_i,S_j$具有最小的序列长度，则存在$S$的最优合并二叉树$T$，使得$S_i$和$S_j$为$T$中最深叶子结点且为兄弟结点。</p>
<p>证明：</p>
<p>假设$S$中的任意两个序列$S_m,S_n$为二叉树$T$的最深叶子且为兄弟。不是一般性，可设$S_m&lt;S_n$，$S_i&lt;S_j$。因为$S_i,S_j$具有最短的序列长度，所以$S_i \leq S_m$，$S_j \leq S_n$。如下图，对二叉树$T$交换叶子$S_m$和$S_i$的位置得到二叉树$T’$，再对$T’$交换$S_n$和$S_j$的位置得到二叉树$T’’$。</p>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220419161732733.png" alt="image-20220419161732733" style="zoom: 50%;">



<p>设合并二叉树$T$所需比较次数用$B(T)$表示，则有：<br>$$<br>B(T) &#x3D; (S_m+S_n-1)+(S_j+S_m+S_n-1)+(S_j+S_m+S_n+S_i-1)\<br>B(T’)&#x3D; (S_i+S_n-1)+(S_j+S_i+S_n-1)+(S_j+S_i+S_n+S_m-1)\<br>B(T)-b(T’)&#x3D;2(S_m - S_i) \geq 0<br>$$<br>同理可得，$B(T’)-B(T’’) \geq 0$，因此有$B(T) \geq B(T’) \geq B(T’’)$，即$T’’$表示合并二叉树为最优的 ，此时序列长度最短的两个序列$S_i,S_j$为最深叶子结点且为兄弟。</p>
<p><strong>（3）最优子结构</strong></p>
<p>设原问题的最优合并二叉树为$T$，$S_i,S_j$是二叉合并树$T$的叶子结点且为兄弟，$Z&#x3D;S_i+S_j$是它们的父亲结点，则树$T’&#x3D;T-{S_1,S_2}$是子问题$S’&#x3D;S-{S_1,S_2} \cup {Z}$的最优合并二叉树。</p>
<p>反证：</p>
<p>若子问题$S’$存在一个更优的合并二叉树$T’’$，即$B(T’’) \lt B(T’)$ ，那么将会有$B(T’’-{Z} \cup {S_1,S_2}) \lt B(T’-{Z} \cup {S_1,S_2})&#x3D;B(T)$，与$T$是原问题的最优解矛盾。</p>
<p><strong>（4）时间复杂度</strong></p>
<p>实现上可以通过优先级队列，主要的复杂度来自于队列的排序过程，即$O(nlogn)$</p>
<p><strong>（5）代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Xiaojian Yuan</span></span><br><span class="line"><span class="comment"> * @Date: 2022-04-19 14:39:07</span></span><br><span class="line"><span class="comment"> * @Description: 最优合并问题</span></span><br><span class="line"><span class="comment"> * 最少合并次数: 每次合并序列长度最短的两个序列</span></span><br><span class="line"><span class="comment"> * 最多合并次数: 每次合并序列长度最长的两个序列</span></span><br><span class="line"><span class="comment"> * @FilePath: /cpp/algorithm/algorithm_homework/4-2/4-2.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="comment">// 升序队列</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; small;</span><br><span class="line">    <span class="comment">// 降序队列</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; big;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        big.<span class="built_in">push</span>(tmp);</span><br><span class="line">        small.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max_res = <span class="number">0</span>, min_res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (big.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出序列长度最大的两个序列进行合并</span></span><br><span class="line">        m = big.<span class="built_in">top</span>();</span><br><span class="line">        big.<span class="built_in">pop</span>();</span><br><span class="line">        n = big.<span class="built_in">top</span>();</span><br><span class="line">        big.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 合并所需的比较次数</span></span><br><span class="line">        max_res += (m + n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新当前序列集合</span></span><br><span class="line">        big.<span class="built_in">push</span>(m + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (small.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出序列长度最小的两个序列进行合并</span></span><br><span class="line">        m = small.<span class="built_in">top</span>();</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">        n = small.<span class="built_in">top</span>();</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 合并所需的比较次数</span></span><br><span class="line">        min_res += (m + n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新当前序列集合</span></span><br><span class="line">        small.<span class="built_in">push</span>(m + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; max_res &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; min_res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-9-汽车加油问题"><a href="#4-9-汽车加油问题" class="headerlink" title="4.9 汽车加油问题"></a>4.9 汽车加油问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220419153654224.png" alt="image-20220419153654224"></p>
<p><strong>（1）贪心策略</strong></p>
<p>如果当前汽车的油足够行驶到下一个加油站，则不加油，否则加油，即让汽车行驶尽可能远的距离再加油。</p>
<p><strong>（2）贪心选择性质</strong></p>
<p>设汽车在加满油行驶的$n$千米内任取两个加油站$X$和$Y$，且它们距起点的距离分别为$x$千米和$y$千米($x \lt y$)。那么，若汽车在加油站$Y$加油不足以到达终点，那么其在加油站$X$加油也必然不能到达终点，因为$x+n \lt y+n$，而在$Y$加油比在$X$加油可以多行驶$y-n$千米。为了使加油次数尽可能的少，据需要使汽车每次加完油都行驶尽可能远的距离。</p>
<p><strong>（3）最优子结构</strong></p>
<p>设原问题的最优解为$A[1:k]$，表示从起点（第$0$个加油站）到终点（第$k+1$个加油站）汽车加油问题。若在第$i$个加油站进行加油，那么总共的加油次数就等于子问题$A[1:i]$的加油次数，加上子问题$A[i+1:k]$的加油次数，再加上$1$，并且$A[1:i]$和$A[i+1:k]$均具有最优子结构。</p>
<p>反证：如果存在更优的加油位置$i’$使$A[1:i’]$或$A[i’+1:k]$的存在更优的解，那么用它替换$A[1:i]$或$A[i+1:k]$得到的$A[1:k]$计算量也会比定义的最优解次数更少，导致矛盾。</p>
<p><strong>（4）代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Xiaojian Yuan</span></span><br><span class="line"><span class="comment"> * @Date: 2022-04-19 19:55:16</span></span><br><span class="line"><span class="comment"> * @Description: 汽车加油问题</span></span><br><span class="line"><span class="comment"> * @FilePath: /cpp/algorithm/algorithm_homework/4-9/3-9.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> gas[k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; gas[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (gas[i] &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += gas[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            i--;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（5）时间复杂度</strong></p>
<p>只需要一次循环即可得到答案，时间复杂度为$O(n)$。</p>
<h2 id="4-10-磁盘文件最优存储问题"><a href="#4-10-磁盘文件最优存储问题" class="headerlink" title="4.10 磁盘文件最优存储问题"></a>4.10 磁盘文件最优存储问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220419210315806.png" alt="image-20220419210315806"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220419210325545.png" alt="image-20220419210325545"></p>
<p><strong>（1）贪心策略</strong></p>
<p>优先将检索概率大的文件存储在磁盘的中间磁道上。</p>
<p>具体的，假设针对文件${f_1,f_2,\dots,f_n}$按检索概率非增序排列，那么首先将$f_1$放在中间磁道($n&#x2F;2$)上，然后将$f_2$和$f_3$分别存放到$f_1$的左右两侧磁道，再将$f_4$存放在$f_2$的旁边，$f_5$存放在$f_3$的旁边， 以此类推。</p>
<p><strong>（2）正确性证明</strong></p>
<p>对于期望时间$\sum p_i p_j d(i,j)$ ，$p_i p_j$是根据输入固定的，我们能优化的为$d(i,j)$，因此对于更大的$p_i p_j$希望其能够具有更小的$d(i,j)$,即概率大的两个磁道尽量靠近。</p>
<p>假设$n$文件中检索概率最大的三个文件分别为$f_i,f_j,f_k (p_i &gt; p_j &gt; p_k)$，设$D_{ijk},D_{jik},D_{jki}$分别表示将概率检索概率最大的文件$f_i$分别放在最左侧，中间和最右侧时的检索时间，可以得到：<br>$$<br>D_{ijk}&#x3D;p_i p_j d + p_i p_k 2d + p_j p_k d \<br>D_{jik}&#x3D;p_j p_i d + p_j p_k 2d + p_i p_k d \<br>D_{jki}&#x3D;p_j p_k d + p_j p_i 2d + p_k p_i d \<br>D_{jik}-D_{ijk}&#x3D;p_j p_k d - p_i p_k d&#x3D;(p_j -p_i)p_k d &lt; 0 \<br>D_{jik}-D_{jki}&#x3D;p_j p_k d - p_j p_i d &#x3D; (p_k - p_i) p_j d &lt; 0 \<br>$$<br>得到$D_{jik}&lt;D_{ijk}，D_{jik}&lt;D_{jki}$，也就是将检索概率最大的文件$f_i$存放在磁道中间位置具有更小的检索时间，满足贪心选择策略。</p>
<p><strong>（3）代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Xiaojian Yuan</span></span><br><span class="line"><span class="comment"> * @Date: 2022-04-19 21:54:23</span></span><br><span class="line"><span class="comment"> * @Description: 磁盘文件最优存储问题</span></span><br><span class="line"><span class="comment"> * 贪心策略: 将检索概率大的文件优先放在靠近中间的磁道上。</span></span><br><span class="line"><span class="comment"> * @FilePath: /cpp/algorithm/algorithm_homework/4-4/4-4.cc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a[n], b[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line">    <span class="comment">// 将检索概率大的存放在靠近中间位置的磁道</span></span><br><span class="line">    <span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">    b[mid] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, k = <span class="number">1</span>; i &lt; n; i++, k++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[mid - k] = a[i];</span><br><span class="line">        i++;</span><br><span class="line">        b[mid + k] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算期望检索时间</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += (b[i] * <span class="number">1.0</span> / sum) * (b[j] * <span class="number">1.0</span> / sum) * (j - i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）时间复杂度</strong></p>
<p>对检索概率排序需要$O(nlogn)$，将文件存放到磁道上需要$O(n)$，计算期望检索时间需要$O(n^2)$.</p>
<h1 id="5-回溯法"><a href="#5-回溯法" class="headerlink" title="5 回溯法"></a>5 回溯法</h1><ul>
<li><p>回溯法的主要思想为<strong>深度优先搜索。</strong></p>
</li>
<li><p>解向量：回溯法希望一个问题的解能够表示成一个 $n$ 元式 $(x_1 ,x_2, \dots, x_n)$ 的形式</p>
</li>
<li><p>常用剪枝函数：</p>
<ul>
<li>用<strong>约束函数</strong>在扩展结点处剪去不满足约束的子树</li>
<li>用<strong>限界函数</strong>剪去得不到最优解的子树</li>
</ul>
</li>
<li><p>解空间：子集树与排列树</p>
<p>&lt;img src&#x3D;”data:image&#x2F;svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1794 1304"/>“ alt&#x3D;”image-20220526114359851” style&#x3D;”zoom:40%;” &#x2F;&gt;</p>
</li>
</ul>
<h2 id="5-1-装载问题"><a href="#5-1-装载问题" class="headerlink" title="5.1 装载问题"></a>5.1 装载问题</h2><p>问题同4.2，有一批共 $n$ 个集装箱要装上 2 艘载重量分别为 $c_1$ 和 $c_2$ 的轮船， 其中集装箱 $i$ 的重量为 $w_i$ ，且 $\sum_{i&#x3D;1}^{n} w_i \leq c_1 + c_2$。装载问题要求确定是否有一个合理的装载方案可将这个集装箱装上这 2 艘轮船；如果有，找出一种装载方案？</p>
<p>思路：容易证明，如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案：先将第一艘轮船尽可能装满，然后将剩余的集装箱装上第二艘轮船。将第一艘轮船尽可能装满等价于选取<strong>全体集装箱的一个子集</strong>， 使该子集中集装箱重量之和最接近 $c_1$。</p>
<ul>
<li><p>解空间：子集树。</p>
</li>
<li><p>左儿子表示选择装入当前集装箱，需要判断可行性；右儿子表示不选择装入当前集装箱，总是可行的，但是通过限界函数判断其子树是否存在更优解，不存在则剪去。</p>
</li>
<li><p>可行性约束函数：选择当前元素后，选择装入的集装箱总重量不超过轮船载重量，$\sum_{i&#x3D;1}^{n}w_ix_i \leq c_1$。</p>
</li>
<li><p>限界函数：当前载重量 $\text{cw}$ + 剩余集装箱的重量 $\text{r}$ $\leq$  当前最优载重量$\text{bestw}$，也就是 $cw + r \leq bestw$ 时，可以剪去右子树。</p>
</li>
<li><p>搜索过程：</p>
</li>
</ul>
<h2 id="5-2-批处理作业调度"><a href="#5-2-批处理作业调度" class="headerlink" title="5.2 批处理作业调度"></a>5.2 批处理作业调度</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165033935.png" alt="image-20220620165033935"></p>
<p>解空间：排列树</p>
<p>优化目标：所有作业在机器2上完成的时间和最小 $\min{\sum_{i&#x3D;1}^{n}F_{2i}}$ </p>
<p>搜索过程：</p>
<ul>
<li>当 $i&gt;n$ 时，算法搜索至叶子结点，得到一个新的作业调度方案。此时算法适时更新当前最优值和相应的当前最佳调度。</li>
<li>当 $i&lt;n$ 时，当前扩展结点位于排列树的第 $(i-1)$ 层，此时算法选择下一个要安排的作业，以深度优先方式递归的对相应的子树进行搜索，对不满足上界约束的结点，则剪去相应的子树。</li>
<li>上界约束，当前在机器二上的完成时间和已经会超过当前最优解，即该子树不存在更优解。</li>
<li>处理作业 $i$ 时，比较 $i$ 在机器1上的结束时间，和作业 $i-1$ 在机器2上的结束时间，较大的那个作为第 $i$ 个任务在机器2上的开始时间。</li>
<li>最坏情况下复杂度 $O(n!)$</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220526153739887.png" alt="image-20220526153739887" style="zoom:50%;">

<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165048914.png" alt="image-20220620165048914" style="zoom:50%;">

<h2 id="5-3-符号三角形"><a href="#5-3-符号三角形" class="headerlink" title="5.3 符号三角形"></a>5.3 符号三角形</h2><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165105013.png" alt="image-20220620165105013" style="zoom:50%;">

<ul>
<li><p>解空间：子集树。用 n 元组 $x[1:n]$ 表示符号三角形的第一行，每个元素选择 <code>+</code> 或 <code>-</code>。</p>
</li>
<li><p>可行性约束函数：当前符号三角形所包含的 “+” 个 “-” 个数均不超过 $n(n+1)&#x2F;4$</p>
</li>
<li><p>最坏情况时间复杂度 $O(n 2^n)$</p>
</li>
</ul>
<h2 id="5-4-n-后问题"><a href="#5-4-n-后问题" class="headerlink" title="5.4 n 后问题"></a>5.4 n 后问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220526161158148.png" alt="image-20220526161158148"></p>
<ul>
<li><p>解空间：排列树，解向量为 $x[1:n]$ 的排列，其中 $x[i]$ 表示皇后 $i$ 放在棋盘的第 $i$ 行的第 $x[i]$ 列。</p>
</li>
<li><p>可行性约束函数：显然各皇后不在同一行，还需要不在同一列（$x[i] \neq x[j]$），以及不在同一对角线（$|i-j| \neq |x_i - x_j|$）。</p>
</li>
<li><p>搜索过程：当 $i&gt;n$，到达叶结点，得到n后问题的一个可行解。当 $i\leq n$时，对当前扩展结点的每个儿子结点进行可行性的检查，并以深度优先的方式递归地对可行子树进行搜索，或剪去不可行子树，</p>
</li>
</ul>
<h2 id="5-5-0-1背包问题"><a href="#5-5-0-1背包问题" class="headerlink" title="5.5 0-1背包问题"></a>5.5 0-1背包问题</h2><ul>
<li><p>解空间：子集树。</p>
</li>
<li><p>每一个扩展结点左儿子表示当前物品装入背包，符合可行性约束才进入左子树；右儿子表示不装入背包，只有存在更优解时才进入右子树。</p>
</li>
<li><p>可行性约束函数：当前装入物品的总重量不超过背包容量，即 $\sum_{i&#x3D;1}^{n}w_ix_i \leq c$</p>
</li>
<li><p>上界函数：当前子树所具有的总价值，不会超过当前最优解，即 $\sum_{j&#x3D;1}^{i}w_iv_i + r \leq bestp$</p>
</li>
<li><p><strong>计算更好的上界的方法是</strong>：<strong>将剩余物品根据单位重量价值排序</strong>，然后依次装入物品，直到装不下时，再装入该物品的一部分而装满背包，此时得到的价值是右子树中解的上界。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165129641.png" alt="image-20220620165129641" style="zoom:50%;">

<h2 id="5-6-最大团问题"><a href="#5-6-最大团问题" class="headerlink" title="5.6 最大团问题"></a>5.6 最大团问题</h2><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165141622.png" alt="image-20220620165141622" style="zoom:50%;">

<ul>
<li>解空间：子集树</li>
<li>可行性约束函数：顶点 $i$ 到已选入顶点集中每一个顶点都有边相连</li>
<li>上界函数：有足够多的可选择顶点 使得算法有可能在右子树中找到更大的团</li>
<li>搜索过程：设当前扩展结点 $Z$ 位于解空间树的第 $i$ 层，进入左子树前，先确认从顶点 $i$ 到已选入的顶点集中每个顶点都有边相连；进入右子树前，先确认还有足够多的可选择顶点，使算法有可能在右子树中找到更大的团。</li>
<li>复杂度 $O(n 2^n)$</li>
</ul>
<h2 id="5-7-图的m着色问题"><a href="#5-7-图的m着色问题" class="headerlink" title="5.7 图的m着色问题"></a>5.7 图的m着色问题</h2><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165204042.png" alt="image-20220620165204042" style="zoom:50%;">

<ul>
<li><p>解空间：<strong>排列树</strong>，是一个 $n+1$ 层的完全 $m$ 叉树。用$x[1:n]$ 表示解向量，其中 $x[i]$ 表示顶点 $i$ 所着颜色为 $x[i]$，第 $i$ 层中每个结点有$m$个儿子，每个儿子对应于 $x[i]$ 的 $m$ 个可能的着色之一。</p>
</li>
<li><p>可行性约束函数：顶点 $i$ 与已着色的相邻顶点颜色不重复</p>
</li>
<li><p>搜索过程：</p>
<ul>
<li>当 $i &gt; n$ 时，算法搜索到叶结点，此时得到一个新的着色方案。</li>
<li>当 $i \leq n$ 时，当前扩展结点$Z$ 有 $m$ 个儿子结点 $x[i]$。对当前扩展结点 $Z$ 的每个儿子结点，用可行性约束函数判断其可行性，并以深度优先的方式递归地对可行子树进行搜索，或剪去不可行子树。</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165215409.png" alt="image-20220620165215409" style="zoom:50%;">

<h2 id="5-8-旅行售货员问题"><a href="#5-8-旅行售货员问题" class="headerlink" title="5.8 旅行售货员问题"></a>5.8 旅行售货员问题</h2><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620165234301.png" alt="image-20220620165234301" style="zoom:50%;">

<ul>
<li>解空间：排列树，解向量为 $x[1:n]$ 的所有排列。</li>
<li>可行性约束函数：是否存在一条从顶点 $x[i-1]$ 到顶点 $x[i]$ 的边，即是否存在相连路径；如果 $i&#x3D;n$ 则还需要判断师傅和一条从顶点 $x[n]$ 到 顶点 1的边，即是否构成一个回路。</li>
<li>上界约束函数：当前已走过路径的费用是否优于已找到的当前最优回路费用 bestc。</li>
<li>搜索过程：<ul>
<li>当 $i&#x3D;n$ 时，当前扩展结点时排列树叶结点的父结点。此时，通过可行性约束判断当前路线是否存在一条满足要求的回路，若存在，则得到一个可行解。然后判断，该可行解的费用是否优于当前已找到的最优路线费用。如果是，则更新当前最优值和最优解。</li>
<li>当 $i &lt; n$ 时，当前扩展结点位于排列树的第 $i-1$ 层。用可行性约束判断图 $G$ 中是否存在从顶点 $x[i-1]$ 到顶点 $x[i]$ 的边，$x[1:i]$ 构成图G的一条路径，且当 $x[1:i]$ 的费用小于当前最优值时算法进入排列树的第 $i$ 层，否则剪去相应的子树。</li>
</ul>
</li>
</ul>
<h2 id="5-9-连续邮资问题"><a href="#5-9-连续邮资问题" class="headerlink" title="5.9 连续邮资问题"></a>5.9 连续邮资问题</h2><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220526174402955.png" alt="image-20220526174402955" style="zoom:50%;">

<ul>
<li>解向量：用 $n$ 元组 $x[1:n]$ 表示 $n$ 种不同的邮票面值，约定它们从小到大排列。$x[1]&#x3D;1$ 是唯一的选择，因为要贴出1的邮资。</li>
<li>可行性约束函数：已选定 $x[1:i-1]$，最大连续邮资区间是 $[1:r]$，接下来 $x[i]$ 的可取值范围是 $[x[i-1]+1:r+1]$</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220526174943356.png" alt="image-20220526174943356" style="zoom:50%;">



<h2 id="5-10-最小电路板长度排列问题"><a href="#5-10-最小电路板长度排列问题" class="headerlink" title="5.10 最小电路板长度排列问题"></a>5.10 最小电路板长度排列问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220505155828933.png" alt="image-20220505155828933"></p>
<p>该问题的解空间是一个<strong>排列树</strong>。当$i&#x3D;n$到达叶节点时，所有电路板已排列，遍历每一个连接块，并对每一个连接块都分别从排列的左侧和右侧对电路板进行编列，从而找到该连接块的长度。我们记录所有连接块中的最大长度，并比较它与当前最优值的大小，如果小于当前最优值，则对最优值和最优解进行更新。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">//电路板数量</span></span><br><span class="line"><span class="type">int</span> m; <span class="comment">//连接块数量</span></span><br><span class="line"><span class="type">int</span> B[<span class="number">25</span>][<span class="number">25</span>];   <span class="comment">//连接块数组</span></span><br><span class="line"><span class="type">int</span> best_len=<span class="number">999999</span>;   <span class="comment">// 最优值</span></span><br><span class="line"><span class="type">int</span> best_x[<span class="number">25</span>]; <span class="comment">// 当前最优解</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">25</span>];      <span class="comment">//当前解</span></span><br><span class="line"><span class="type">int</span> tmp_len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, tmp;</span><br><span class="line">    <span class="keyword">if</span> (t == n)     <span class="comment">//到达叶节点，得到一个排列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算当前排列的长度</span></span><br><span class="line">        tmp_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">//遍历连接块</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 从左侧遍历第i个连接块的电路板</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 找到连接块i在当前排列最左侧的电路板j</span></span><br><span class="line">                <span class="keyword">if</span> (B[x[j]][i] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    l = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从右侧遍历第i个连接块的电路板</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 找到连接块i在当前排列最左侧的电路板j</span></span><br><span class="line">                <span class="keyword">if</span> (B[x[j]][i] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    r = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录连接板的最大长度</span></span><br><span class="line">            <span class="keyword">if</span> (tmp_len &lt; r - l) </span><br><span class="line">            &#123;</span><br><span class="line">                tmp_len = r - l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要使最大长度最小</span></span><br><span class="line">        <span class="keyword">if</span> (tmp_len &lt; best_len) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 记录最优值</span></span><br><span class="line">            best_len = tmp_len;</span><br><span class="line">            <span class="comment">// 记录最优解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                best_x[i] = x[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有到达叶节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// swap(x[i], x[t]);</span></span><br><span class="line">        tmp = x[i];</span><br><span class="line">        x[i] = x[t];</span><br><span class="line">        x[t] = tmp;</span><br><span class="line">        <span class="built_in">traceback</span>(t + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// swap(x[i], x[t]);</span></span><br><span class="line">        tmp = x[i];</span><br><span class="line">        x[i] = x[t];</span><br><span class="line">        x[t] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; B[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化排列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; best_len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; best_x[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-11-无和集问题"><a href="#5-11-无和集问题" class="headerlink" title="5.11 无和集问题"></a>5.11 无和集问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220506163309034.png" alt="image-20220506163309034"></p>
<p>解空间为一棵子集树，树的每一层表示一个子集。</p>
<p>可行性条件：对于一个已有的递增子集，现在要判断新增的数能否加入该子集中。如果通过判断“任意两个数的和不在该子集中”，那么就需要双重循环遍历进行判断。因此，可以转换一下思路，让新增的数与子集中每一个数做减法，若如果它们的差值也存在于该子集中，则说明该数不能插入该集合中，这种方法只需要一次循环即可判断。</p>
<p>思路：</p>
<p>对于每一个新增的数，首先进行可行性的判断，判断其是否能加入到当前层所表示的子集中：</p>
<ul>
<li>如果不能插入当前层表示的子集，就继续判断该新增的数其能否插入到下一层所表示子集中。</li>
<li>如果可以插入当前层表示的子集，那么就存在两个儿子节点，分别为插入当前子集和不插入当前子集。<ul>
<li>如果选择插入当前子集，则从第一层开始再将判断下一个新增的数。</li>
<li>如果选择不插入当前子集，则继续判断是否将该数插入下一个子集。</li>
</ul>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无和集问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">best_res[n][0]表示第n个集合中的元素个数</span></span><br><span class="line"><span class="comment">从best_res[n][1]到best_res[n][best_res[n][0]]表示集合n中具体的数</span></span><br><span class="line"><span class="comment">inSet[i][j] 表示第i个子集中是否有j这个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> best_res[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> tmp_res[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> best_k, tmp_k = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> inSet[MAXN][MAXN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解空间树的每一层代表一个子集，判断当前的tmp_k是否能够插入到这个集合中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前k不如最优k，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (tmp_k &lt;= best_k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 否则更新最优值</span></span><br><span class="line">        best_k = tmp_k;</span><br><span class="line">        <span class="comment">// 更新最优解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= tmp_res[i][<span class="number">0</span>]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                best_res[i][j] = tmp_res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断当前的tmp_k是否能够插入当前层的子集</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 遍历该层所表示的子集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tmp_res[t][<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可行性条件: (任意两个数的差值不在这个集合中)</span></span><br><span class="line"><span class="comment">            tmp_k减去这个元素后tmp_res[t][i]得到的值已经在这个集合中，并且不是这个数本身(排除掉集合中的0)，flag=False</span></span><br><span class="line"><span class="comment">            tmp_k减去这个元素后tmp_res[t][i]得到的值不在这个集合中，flag=True</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (inSet[t][tmp_k - tmp_res[t][i]] &amp;&amp; tmp_k - tmp_res[t][i] != tmp_res[t][i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不能插入当前层的集合，那么继续判断能否插入到下一层的集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traceback</span>(t + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以插入当前层的集合(选择插入或者不插入)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果插入当前集合（左子树）</span></span><br><span class="line">            tmp_res[t][<span class="number">0</span>]++;                   <span class="comment">// 该集合中元素数量加1</span></span><br><span class="line">            tmp_res[t][tmp_res[t][<span class="number">0</span>]] = tmp_k; <span class="comment">// 将tmp_k加入到该集合的最后</span></span><br><span class="line">            inSet[t][tmp_k] = <span class="literal">true</span>;            <span class="comment">// 更新标记，该元素在该集合中</span></span><br><span class="line">            tmp_k++;                           <span class="comment">// 当前tmp_k所表示的数字已分配到集合，考虑tmp_k+1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对tmp_k+1，重新从第0个集合开始判断</span></span><br><span class="line">            <span class="built_in">traceback</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不插入当前集合</span></span><br><span class="line">            tmp_res[t][<span class="number">0</span>]--;</span><br><span class="line">            tmp_k--;</span><br><span class="line">            inSet[t][tmp_k] = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">traceback</span>(t + <span class="number">1</span>); <span class="comment">// 是否插入下一个集合</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; --best_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= best_res[i][<span class="number">0</span>]; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; best_res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-12-工作分配问题"><a href="#5-12-工作分配问题" class="headerlink" title="5.12 工作分配问题"></a>5.12 工作分配问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220506183739123.png" alt="image-20220506183739123"></p>
<p>解空间为一个经典的排列树，得到最优解为<code>x[n]</code>，表示将第<code>i</code>个工作分配给第<code>x[i]</code>个人去做，在到达叶节点得到一个排列后，只需要根据当前排列查询每个工作<code>i</code>的所需的费用<code>c[i][x[i]]</code>进行累加，即可得到总费用。如果总费用小于最优值，则更新当前最优值和最优解。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> c[MAXN][MAXN];             <span class="comment">// c[i][j]表示工作i分配个第j个人所需的费用</span></span><br><span class="line"><span class="type">int</span> tmp_x[MAXN], best_x[MAXN]; <span class="comment">// best_x[i] 表示第i个工作由第best_x[i]个人完成,</span></span><br><span class="line"><span class="type">int</span> best_res = <span class="number">999</span>, tmp_res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == n)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算当前排列的所需要的费用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="comment">//第i个工作由第x[i]个完成所需要的费用</span></span><br><span class="line">            tmp_res += c[i][tmp_x[i]];</span><br><span class="line">        <span class="keyword">if</span> (tmp_res &lt; best_res)</span><br><span class="line">        &#123;</span><br><span class="line">            best_res = tmp_res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                best_x[i] = tmp_x[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp;</span><br><span class="line">            tmp = tmp_x[i];</span><br><span class="line">            tmp_x[i] = tmp_x[t];</span><br><span class="line">            tmp_x[t] = tmp;</span><br><span class="line">            <span class="built_in">traceback</span>(t + <span class="number">1</span>);</span><br><span class="line">            tmp = tmp_x[i];</span><br><span class="line">            tmp_x[i] = tmp_x[t];</span><br><span class="line">            tmp_x[t] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; c[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化排列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp_x[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; best_res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; best_x[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-13-拉丁矩阵问题"><a href="#5-13-拉丁矩阵问题" class="headerlink" title="5.13 拉丁矩阵问题"></a>5.13 拉丁矩阵问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220506190719081.png" alt="image-20220506190719081"></p>
<p>共有<code>n</code>种宝石，排列成<code>m*n</code>的矩阵，因此每一行均为$n$种组成的排列，解空间为排列树。对矩阵的每一行进行全排列，同时满足可行性条件，即该行与之前所有行的每一列没有形状重复的宝石。</p>
<p>因此，用函数<code>ok(r,c)</code>判断第<code>c</code>列的前<code>r</code>行是否存在重复的宝石，回溯方法<code>traceback(r,c)</code>对每一行进行排列，使用排列树的框架，没有优化目标，找出所有可行解即可，当搜索到最后一行最后一列时，可行解的数量加一。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拉丁矩阵问题</span></span><br><span class="line"><span class="comment">n种宝石,m*n的矩阵,每一行是n个宝石的一个排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> matrix[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断第c列的前r行是否有同一种宝石</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][c] == matrix[r][c])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="comment">//  对每一行的n个宝石进行排列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// swap列</span></span><br><span class="line">        tmp = matrix[r][c];</span><br><span class="line">        matrix[r][c] = matrix[r][i];</span><br><span class="line">        matrix[r][i] = tmp;</span><br><span class="line">        <span class="comment">// 判断该行的排列是否与上面的行有重复的列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ok</span>(r, c))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == m - <span class="number">1</span>)     <span class="comment">// 到达最后一行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == n - <span class="number">1</span>) <span class="comment">// 到达最后一列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    res++;      <span class="comment">// 获得一个可行解</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>             <span class="comment">// 未到达最后一列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">traceback</span>(r, c + <span class="number">1</span>); <span class="comment">//  继续判断下一列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 未到达最后一行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == n - <span class="number">1</span>) <span class="comment">// 到达某一行的最后一列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">traceback</span>(r + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>            </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">traceback</span>(r, c + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmp = matrix[r][c];</span><br><span class="line">        matrix[r][c] = matrix[r][i];</span><br><span class="line">        matrix[r][i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化每一行都是1,2,...,n的排列</span></span><br><span class="line">            matrix[i][j] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">traceback</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-分支限界法"><a href="#6-分支限界法" class="headerlink" title="6 分支限界法"></a>6 分支限界法</h1><ul>
<li><p>求解目标不同</p>
<ul>
<li>回溯法找出解空间中满足约束条件的<strong>所有解</strong>。</li>
<li>分支限界法找出满足约束条件的一个解，或是在满足约束条件的解中找出某种意义下的最优解</li>
</ul>
</li>
<li><p>搜索方式不同</p>
<ul>
<li>回溯法：<strong>深度优先搜索</strong></li>
<li>分支限界法：<strong>广度优先搜索</strong>或最小耗费（最大效益）优先</li>
</ul>
</li>
<li><p>活结点扩展方式</p>
<ul>
<li>分支限界法中每一个活结点只有一次机会成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，重复上述结点扩展过程，一直持续到找到所需的解或 活结点表为空时为止。</li>
<li>回溯法中的结点有可能多次成为活结点。</li>
</ul>
</li>
</ul>
<p>（2）常用的两种分支限界法</p>
<ul>
<li>队列式 (FIFO) 分支限界法<ul>
<li>按照队列<strong>先进先出</strong>（FIFO）原则选取下一个节点为扩展节点</li>
</ul>
</li>
<li>优先队列式分支限界法<ul>
<li>按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点</li>
<li>在搜索解空间过程中增加了启发式方法，并通过优先级数值体现</li>
</ul>
</li>
</ul>
<h2 id="6-1-单源最短路径问题"><a href="#6-1-单源最短路径问题" class="headerlink" title="6.1 单源最短路径问题"></a>6.1 单源最短路径问题</h2><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220620164839384.png" alt="image-20220620164839384" style="zoom:50%;">

<ul>
<li><p>以当前结点的路径长度作为优先级建立最小堆，从而实现活结点的优先级队列。</p>
</li>
<li><p>算法从图 G 的源顶点 s 和空优先队列开始，结点 s 被扩展后，它的儿子结点被依次插入堆中</p>
</li>
<li><p>从活结点列表中取出具有最小当前路径长度的结点作为当前扩展结点，并依次检查与当前扩展结点相邻的所有顶点：</p>
<ul>
<li>如果从当前扩展结点 i 到顶点 j 有边可达<strong>（可行性约束）</strong></li>
<li>从源出发，途经顶点 i 再到顶点 j 的所相应的路径的长度小于当前最优路径长度<strong>（上界约束）</strong>，否则剪去改结点为根的子树。</li>
<li>则将该顶点作为活结点插入到活结点优先队列中</li>
</ul>
</li>
<li><p>结点的扩展过程一直继续到活结点优先队列为空时为止</p>
</li>
</ul>
<h2 id="6-2-装载问题"><a href="#6-2-装载问题" class="headerlink" title="6.2 装载问题"></a>6.2 装载问题</h2><p>解空间为子集树，节点的左子树表示将此集装箱装上船，右子树表示不将此 集装箱装上船。</p>
<p>（1）基于队列的分支限界</p>
<ul>
<li>检测当前扩展结点的左儿子是否为可行结点（<strong>可行性约束</strong>，即不超过轮船载重量），如果是则加入到活结点列表中。</li>
<li>将其右儿子结点加入到活结点队列中 ，右儿子结点一定是可行结点，但是需要用<strong>限界函数</strong>判断是否存在更优解。<ul>
<li>设 bestw 是当前最优解，ew 是当前扩展结点所相应的重量，r 是剩 余集装箱的重量</li>
<li>则当 ew+r $\leq$ bestw 时，可将其右子树剪去，因为此时若要船装最多z集装箱，就应该把此箱装上船</li>
</ul>
</li>
<li>另外，为了确保右子树成功剪枝，应该在算法每一次进入左子树的 时候更新 bestw 的值</li>
</ul>
<p>（2）基于优先级队列的分支限界</p>
<ul>
<li>用最大优先队列存储活结点表<ul>
<li>活结点 x 在优先队列中的优先级定义为<strong>从根结点到结点 x 的路径所相应的载重量</strong>再加上<strong>剩余集装箱的重量之和</strong></li>
<li>优先队列中优先级最大的活结点成为下一个扩展结点</li>
<li>以结点 x 为根的子树中所有结点相应的路径的载重量不超过它的优先级</li>
<li>子集树中叶结点所相应的载重量与其优先级相同</li>
</ul>
</li>
<li>优先队列式分支限界的终结<ul>
<li>一旦有一个叶结点成为当前扩展结点，则可以断言该叶结点所相应的解即为最优解，此时可终止算法</li>
</ul>
</li>
</ul>
<h2 id="6-3-布线问题"><a href="#6-3-布线问题" class="headerlink" title="6.3 布线问题"></a>6.3 布线问题</h2><p>FIFO队列式分支限界法：</p>
<ul>
<li>从起始位置 a 开始将它作为第一个扩展结点</li>
<li>与扩展结点相邻并且可达的方格成为可行结点<strong>（可行性约束）</strong>，将其加入到活结点队列中，并且将这些方格标记为 1。</li>
<li>算法从活结点队列中取出队首元素作为下一个扩展结点，并将与 当前扩展结点相邻且未标记过的方格标记为 2，并存入活结点队列。</li>
<li>一直继续到算法搜索到目标方格 b 或活结点队列为空</li>
</ul>
<h2 id="6-4-0-1背包问题"><a href="#6-4-0-1背包问题" class="headerlink" title="6.4 0-1背包问题"></a>6.4 0-1背包问题</h2><p>要对输入数据进行预处理，将各物品<strong>依其单位重量价值从大到小进行排列</strong></p>
<p>优先级队列分支限界法：</p>
<ul>
<li><p>优先级定义为：“已装入的物品价值”加上“剩下最大单位重量价值的物品装满剩余容量”的价值和，也就是当前结点可能装入背包的价值上限。</p>
</li>
<li><p>可行性约束：装入该物品后的重量是否超过背包总容量</p>
</li>
<li><p>上界约束：当前已装入的物品价值加上用剩余最大单位重量价值的物品装满剩余容量的价值和，是否超过当前最优价值（因为已经按单位价值排序，因此直接按顺序装满背包即可）。</p>
</li>
<li><p>首先，检查当前扩展结点的左儿子是否满足<strong>可行性约束</strong>，如果左儿子是可行结点，则将其加入到活结点优先队列中。</p>
</li>
<li><p>当前扩展解的右儿子一定是可行结点，仅当右儿子结点满足<strong>上界约束</strong>时，才将其加入到子集树和活结点优先队列中。</p>
</li>
<li><p>不断从活结点列表中取出队首元素作为扩展结点，直到到达叶结点得到问题的最优值。</p>
</li>
</ul>
<h2 id="6-5-旅行售货员问题"><a href="#6-5-旅行售货员问题" class="headerlink" title="6.5 旅行售货员问题"></a>6.5 旅行售货员问题</h2><p>某售货员要到若干城市去推销商品，已知各城市之间的路程(或旅费)，他要选定一条从驻地出发，经过每个城市一 次，最后回到驻地的路线，使总的路程(或总旅费)最小。</p>
<ul>
<li><p>解空间为<strong>排列树</strong>，排列树，解向量为 $x[1:n]$ 的所有排列。</p>
</li>
<li><p><strong>优先级</strong>定义从源结点到当前结点路程所需的费用加上当前扩展结点最小出边费用，用最小堆实现。</p>
</li>
<li><p>可行性约束：对于当前扩展结点 $i$，是否存在一条从顶点 $x[i-1]$ 到顶点 $x[i]$ 的边，即是否存在相连路径；如果 $i&#x3D;n$ 则还需要判断师傅和一条从顶点 $x[n]$ 到 顶点 1的边，即是否构成一个回路。</p>
</li>
<li><p>上界约束函数：当前已走过路径的费用加上当前扩展结点最小出边费用，是否优于已找到的当前最优回路费用 bestc。</p>
</li>
<li><p>搜索过程：</p>
<ul>
<li><p>当 $s&#x3D;n-2$，即当前扩展结点时排列树中某个叶结点的父结点。判断该叶结点是否可以构成一条可行回路（满足可行性约束），并且费用小于当前最小费用（满足界限约束），则将该叶结点 插入优先队列中，否则舍去该叶结点。</p>
</li>
<li><p>当 $s \lt n-2$，产生当前扩展结点的所有儿子结点，对于每一个儿子结点，判断是否满足可行性约束（即与剩下的顶点存在相连的边）。对于每一个可行的儿子结点，再判断其是否满足界限约束（当前扩展结点的每个儿子结点，计算出其路径所需的费用加上该儿子结点最小出边的费用），若小于最优解，则将该可行儿子结点加入到活结点优先队列中。</p>
</li>
<li><p>while循环的终止：条件是排列树的<strong>一个叶结点成为当前扩展结点</strong>，当 $s&#x3D;n-1$ 时，已找到的回路前缀是 $x[0:n-1]$，已包含所有 $n$ 个顶点。当 $s&#x3D;n-1$ 时，相应的扩展结点表示叶结点，剩余活结点不小于已找到回路的费用，算法终止。</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-6-0-1背包问题的栈式分支限界"><a href="#6-6-0-1背包问题的栈式分支限界" class="headerlink" title="6.6 0-1背包问题的栈式分支限界"></a>6.6 0-1背包问题的栈式分支限界</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220510155552789.png" alt="image-20220510155552789"></p>
<p>首先根据物品的单位价值进行进行非升序排列。算法不断扩展结点，首先检查当前扩展结点的左儿子是否为可行结点，可行性约束为已入背包的重量加上该结点重量后是否超过背包总重量，如果左儿子是可行结点，则将其加入到活结点栈中。当前扩展结点的右儿子一定是可行结点，判断其是否符合上界约束，即其所包含的子数存在更优解时才将其加入到活结点栈中。</p>
<p>分支限界法与回溯法的区别在于，分支限界法中每一个活结点只有一次机会，且活结点一旦成为扩展结点，就一次性产生其所有儿子结点。此后，从活结点表中取下一结点作为当前扩展结点，直到找到所需的解或活结点表为空，其主要思想为广度遍历优先。而回溯法中的结点有可能多次成为活结点，其主要思想为深度遍历优先。</p>
<h2 id="6-7-最小长度电路板排列问题"><a href="#6-7-最小长度电路板排列问题" class="headerlink" title="6.7 最小长度电路板排列问题"></a>6.7 最小长度电路板排列问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220510155611347.png" alt="image-20220510155611347"></p>
<p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220510155619887.png" alt="image-20220510155619887"></p>
<p>该问题的解空间是一颗排列树，用 <code>BoardNode</code>类表示排列树的每个结点，其中包含 <code>x</code> 表示相应结点的电路板排列，<code>s</code> 表示该结点已确定的电路板排列<code>x[1:s]</code>，<code>cd</code>表示当前的长度，数组<code>low</code>和<code>high</code>分别表示每个连接块第一个和最后一个电路板的位置，当需要计算当前排列的最小长度是，只要依次将<code>high</code>和<code>low</code>中的元素做减法，并取其中最小值即可。</p>
<p>当使用队列式分支限界法时，依次对排列树内部结点进行扩展，当<code>s=n-1</code>时，已排定<code>n-1</code>块电路板，当前扩展结点是排列树中叶结点的父结点，<code>x</code>表示相应于该叶结点的电路板排列，计算出此时<code>x</code>的长度，若小于当前的最优值，则更新最优值和最优解。当<code>s&lt;n-1</code>时，算法依次产生当前扩展结点的所有儿子结点。对于每一个儿子结点，计算出其长度，若小于当前的最优值，则将该儿子结点插入到活结点队列中，否则舍去该儿子结点。do-while循环依次从活结点队列中取出结点作为当前扩展结点，直到队列为空时，算法结束。</p>
<p>当使用优先级队列分支限界法时，用当前结点的长度<code>cd</code>作为优先级插入优先级队列中（最小堆）。do-while循环依次从活结点优先级队列中取出结点作为当前扩展结点，如果当前扩展结点的长度<code>cd</code>不小于当前最小长度，则优先级毒烈中其余活结点都不可能导致最优解，算法结束。</p>
<h2 id="6-8-最小权顶点覆盖问题"><a href="#6-8-最小权顶点覆盖问题" class="headerlink" title="6.8 最小权顶点覆盖问题"></a>6.8 最小权顶点覆盖问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220510155638419.png" alt="image-20220510155638419"></p>
<ul>
<li><p>该问题的解空间是一个子集树，以当前扩展结点的权重作为优先级建立最小堆，从而实现活结点优先级队列。</p>
</li>
<li><p>设组成顶点覆盖的集合为<code>U</code>，约束条件为集合 <code>U</code>中的点集能够完成对图<code>G</code>的顶点覆盖。具体做法可以每个活结点开辟一个数组<code>c</code>，每次将顶点<code>i</code>加入到集合<code>U</code>时，依次判断<code>n</code>个顶点是否与<code>i</code>有相连的边，如果顶点<code>j</code>与顶点<code>i</code>有边，则将<code>c[j]</code>加一，若最终<code>c[j]=0</code>，则说明当前<code>U</code>并没有覆盖到顶点<code>j</code>。利用数组<code>c</code>，可以判断当前扩展结点是否完成顶点覆盖，即遍历所有顶点<code>j(1&lt;=j&lt;=n)</code>，若 <code>j</code> 既不是 <code>U</code> 中的点 <code>(E.x[j]=0)</code>，也没有与 <code>U</code> 中的顶点相连 <code>(E.c[j]=0）</code>，则说明未完成顶点覆盖。</p>
</li>
<li><p>当 <code>i&gt;n</code>时，到达叶结点，判断当前最优解是否完成了顶点覆盖，若已完成则更新最优值和最优解。</p>
</li>
<li><p>当<code>i&lt;n</code>时，对于当前扩展结点，如果没有完成顶点覆盖，才有必要将左儿子加入到活结点队列中，否则无需选择左儿子来进一步增加集合U中的权重；该问题无法设定界限约束，右儿子则直接加入到活结点队列中，因为如果只选择右儿子，那么覆盖集顶点权重一定更小，但是却不一定能够完成顶点覆盖</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小权顶点覆盖问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MinHeap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// //求解最小权覆盖问题的类,融合了所有函数和所需的参数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">DealNode</span>; <span class="comment">//将VC声明为友元类，即可以在VC类中访问HeapNode类中的私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> cn; &#125; <span class="comment">// 定义优先级(最小堆)</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// i表示当前层级，cn表示当前权重，x表示当前解，</span></span><br><span class="line">    <span class="comment">// c[i]=0，表示顶点i既不在覆盖集合U中，也不存在U中的顶点与其相连，说明该顶点i未被覆盖</span></span><br><span class="line">    <span class="type">int</span> i, cn, *x, *c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DealNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">MinCover</span><span class="params">(<span class="type">int</span> **, <span class="type">int</span>[], <span class="type">int</span>)</span></span>; <span class="comment">//将MinCover声明为友元函数，既可以在MinCover中访问该类的私有成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BBVC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cover</span><span class="params">(HeapNode E)</span></span>; <span class="comment">//判断当前图E是否全部覆盖了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddLiveNode</span><span class="params">(MinHeap&lt;HeapNode&gt; &amp;H, HeapNode E, <span class="type">int</span> cn, <span class="type">int</span> i, <span class="type">bool</span> ch)</span></span>;</span><br><span class="line">    <span class="type">int</span> **a, n, *w, *bestx, bestn;</span><br><span class="line">    <span class="comment">// a表示邻接矩阵，n表示结点数量，数组w存储结点权重，bestw表示最优解， bestn表示最优值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DealNode::BBVC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MinHeap&lt;HeapNode&gt; <span class="title">H</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line">    HeapNode E; <span class="comment">// 当前扩展结点</span></span><br><span class="line">    E.x = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    E.c = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        E.x[j] = E.c[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, cn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) <span class="comment">// 到达叶结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前扩展结点是否已经完成顶点覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">cover</span>(E))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新最优解和最优值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                    bestx[j] = E.x[j];</span><br><span class="line">                bestn = cn;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 未到达叶结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 还未完成顶点覆盖，才有必将左儿子加入活结点优先级队列中</span></span><br><span class="line">            <span class="comment">// 如果已经符合顶点覆盖条件了，那就没有必要选择左儿子来增加集合U中的权重了</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">cover</span>(E))</span><br><span class="line">                <span class="built_in">AddLiveNode</span>(H, E, cn, i, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将右儿子加入优先级队列,这里无法进行界限约束，</span></span><br><span class="line">            <span class="comment">// 因为如果只选择右儿子，那么覆盖集顶点权重一定更小，但是不一定能够完成顶点覆盖</span></span><br><span class="line">            <span class="built_in">AddLiveNode</span>(H, E, cn, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (H.<span class="built_in">IsEmpty</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 从活结点优先级队列中取出扩展结点</span></span><br><span class="line">        H.<span class="built_in">RemoveMin</span>(E);</span><br><span class="line">        cn = E.cn;</span><br><span class="line">        i = E.i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断当前图是否完成顶点覆盖</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DealNode::cover</span><span class="params">(HeapNode E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果此时结点j既不是覆盖集合U中的点，也没有U中的点与其相连，则说明存在未覆盖的顶点j</span></span><br><span class="line">        <span class="keyword">if</span> (E.x[j] == <span class="number">0</span> &amp;&amp; E.c[j] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将扩展结点加入到优先级活结点队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DealNode::AddLiveNode</span><span class="params">(MinHeap&lt;HeapNode&gt; &amp;H, HeapNode E, <span class="type">int</span> cn, <span class="type">int</span> i, <span class="type">bool</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建新的堆结点</span></span><br><span class="line">    HeapNode N;</span><br><span class="line">    N.x = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    N.c = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        N.x[j] = E.x[j];</span><br><span class="line">        N.c[j] = E.c[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第i个顶点是否加入到集合U中</span></span><br><span class="line">    N.x[i] = ch;</span><br><span class="line">    <span class="comment">// 若加入到集合U中</span></span><br><span class="line">    <span class="keyword">if</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新集合U中的顶点总权重</span></span><br><span class="line">        N.cn = cn + w[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j])</span><br><span class="line">                <span class="comment">// 第j个顶点是否与集合U中的顶点i有边相连，若右边则说明该顶点j已被覆盖</span></span><br><span class="line">                N.c[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        N.cn = cn;</span><br><span class="line">    &#125;</span><br><span class="line">    N.i = i;</span><br><span class="line">    H.<span class="built_in">Insert</span>(N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MinCover完成最小覆盖计算</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinCover</span><span class="params">(<span class="type">int</span> **a, <span class="type">int</span> v[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DealNode Y;</span><br><span class="line">    Y.w = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        Y.w[j] = v[j];</span><br><span class="line">    Y.a = a;</span><br><span class="line">    Y.n = n;</span><br><span class="line">    Y.bestx = v;</span><br><span class="line">    Y.<span class="built_in">BBVC</span>();</span><br><span class="line">    <span class="keyword">return</span> Y.bestn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, e, u, v; <span class="comment">// n结点数,e边数,u,v为结点编号</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[n + <span class="number">1</span>]; <span class="comment">// 权重</span></span><br><span class="line">    <span class="comment">//邻接矩阵(创建二维数组)</span></span><br><span class="line">    <span class="type">int</span> **a;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="type">int</span> *[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= e; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        a[u][v] = <span class="number">1</span>;</span><br><span class="line">        a[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MinCover</span>(a, p, n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最小堆<code>MinHeap.h</code>的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> <span class="comment">//最小堆类；</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinHeap</span>(Type a[], <span class="type">int</span> n);   <span class="comment">//带两参数的构造函数，在此程序中没有应用；</span></span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">int</span> ms);            <span class="comment">//构造函数重载，只初始化堆的大小，对堆中结点不初始化；另外，堆元素的存储是以数组</span></span><br><span class="line">    ~<span class="built_in">MinHeap</span>();                 <span class="comment">//形式，且无父、子指针，访问父亲结点，利用数组标号进行；</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> Type &amp;x)</span></span>; <span class="comment">//插入堆中一个元素；</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">RemoveMin</span><span class="params">(Type &amp;x)</span></span>;    <span class="comment">//删除堆顶最小结点；</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;           <span class="comment">//使堆为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FilterDown</span><span class="params">(<span class="type">const</span> <span class="type">int</span> start, <span class="type">const</span> <span class="type">int</span> endOfHeap)</span></span>; <span class="comment">//自顶向下构造堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FilterUp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> start)</span></span>;                        <span class="comment">//自底向上构造堆</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type *heap;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> defaultSize;</span><br><span class="line">    <span class="type">int</span> currentSize; <span class="comment">//堆当前结点个数大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">MinHeap&lt;Type&gt;::<span class="built_in">MinHeap</span>(<span class="type">int</span> ms) : <span class="built_in">defaultSize</span>(<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    maxSize = (ms &gt; defaultSize) ? ms : defaultSize;</span><br><span class="line">    heap = <span class="keyword">new</span> Type[maxSize];</span><br><span class="line">    currentSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">MinHeap&lt;Type&gt;::<span class="built_in">MinHeap</span>(Type a[], <span class="type">int</span> n) : <span class="built_in">defaultSize</span>(<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    maxSize = (n &gt; defaultSize) ? n : defaultSize;</span><br><span class="line">    heap = <span class="keyword">new</span> Type[maxSize];</span><br><span class="line">    currentSize = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        heap[i] = a[i];</span><br><span class="line">    <span class="type">int</span> curPos = (currentSize - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (curPos &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FilterDown</span>(curPos, currentSize - <span class="number">1</span>);</span><br><span class="line">        curPos--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">MinHeap&lt;Type&gt;::~<span class="built_in">MinHeap</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt;::<span class="built_in">FilterDown</span>(<span class="type">const</span> <span class="type">int</span> start, <span class="type">const</span> <span class="type">int</span> endOfHeap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= endOfHeap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; endOfHeap &amp;&amp; heap[j] &gt; heap[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; heap[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap[i] = heap[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt;::<span class="built_in">FilterUp</span>(<span class="type">const</span> <span class="type">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = start, j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    Type temp = heap[i];</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= heap[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap[i] = heap[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;Type&gt;::<span class="built_in">RemoveMin</span>(Type &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Heap empty!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = heap[<span class="number">0</span>];</span><br><span class="line">    heap[<span class="number">0</span>] = heap[currentSize - <span class="number">1</span>];</span><br><span class="line">    currentSize--;</span><br><span class="line">    <span class="built_in">FilterDown</span>(<span class="number">0</span>, currentSize - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;Type&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> Type &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Heap Full!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[currentSize] = x;</span><br><span class="line">    <span class="built_in">FilterUp</span>(currentSize);</span><br><span class="line">    currentSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;Type&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> MinHeap&lt;Type&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize == maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;Type&gt;::<span class="built_in">MakeEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    currentSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">int</span> MinHeap&lt;Type&gt;::<span class="built_in">Size</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> currentSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-9-最小重量机器设计问题"><a href="#6-9-最小重量机器设计问题" class="headerlink" title="6.9 最小重量机器设计问题"></a>6.9 最小重量机器设计问题</h2><p><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/algorithm_course/image-20220510155649875.png" alt="image-20220510155649875"></p>
<p>解空间为深度为n的m叉树。</p>
<p>解空间树的第 <code>i</code> 层表示第 <code>i</code> 个物品，每一层有 <code>m</code> 个结点，分表表示对应的供应商，用数组 <code>best_x[n]</code> 表示最优解，其中 <code>bestx[i]</code> 表示第 <code>i</code> 个物品从第 <code>bestx[i]</code> 个供应商采购。</p>
<p>以当前扩展结点的重量作为优先级建立最小堆，从而实现活结点优先级队列。</p>
<p>当活结点队列不为空时，依次从中取出扩展结点，如果未到达叶结点，则遍历当前扩展结点的所有儿子结点（即遍历所有供应商）。</p>
<ul>
<li>如果儿子结点为叶结点，每次遍历供应商i时，判断当前解是否符合约束条件，以及是否为更优解，适当更新最优值与最优解。</li>
<li>如果儿子结点不是叶结点，符合约束条件并又可能存在更优解，则将儿子结点加入到活结点优先级队列中。</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小重量机器设计问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n个物品，m个供应商，最大价格d</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n, m, d;</span><br><span class="line"><span class="type">int</span> best_w = <span class="number">0x3f3f3f</span>; <span class="comment">// 最优值，即最小重量</span></span><br><span class="line"><span class="type">int</span> best_x[maxn];      <span class="comment">// 最优解，bestx[i]表示第i个物品从第bestx[i]个供应商采购</span></span><br><span class="line"><span class="comment">// c[i][j]第i个物品从第m个供应商采购的重量,w[i][j]为对应的价格</span></span><br><span class="line"><span class="type">int</span> c[maxn][maxn], w[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// weight表示当前重量，cost表示当前话费，，source表示供应商</span></span><br><span class="line">    <span class="comment">// level表示层级，也表示第level个物品，其子结点为所有供应商</span></span><br><span class="line">    <span class="comment">// tmp_x存储当前最优解</span></span><br><span class="line">    <span class="type">int</span> weight, cost, level, source, tmp_x[maxn];</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> w, <span class="type">int</span> c, <span class="type">int</span> l, <span class="type">int</span> s) : <span class="built_in">weight</span>(w), <span class="built_in">cost</span>(c), <span class="built_in">level</span>(l), <span class="built_in">source</span>(s) &#123;&#125;</span><br><span class="line">    <span class="comment">//小根堆, 返回true，则证明前者优先级低于后者</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//若weigth&gt;a.weigth为true，则a的优先级更高，即weigth小的对象优先级更高</span></span><br><span class="line">        <span class="keyword">if</span> (weight != a.weight)</span><br><span class="line">            <span class="keyword">return</span> weight &lt; a.weight; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (level != a.level)</span><br><span class="line">            <span class="keyword">return</span> a.level &lt; level;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> source &gt; a.source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; c[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化活结点优先级队列</span></span><br><span class="line">    <span class="comment">// 第一个物品选择哪一个供应商</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        node curr = <span class="built_in">node</span>(w[<span class="number">1</span>][i], c[<span class="number">1</span>][i], <span class="number">1</span>, i);</span><br><span class="line">        <span class="comment">// 约束条件: 价格不超过d</span></span><br><span class="line">        <span class="keyword">if</span> (curr.cost &lt;= d)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 第一个物品选择第i个供应商</span></span><br><span class="line">            curr.tmp_x[<span class="number">1</span>] = i;</span><br><span class="line">            <span class="comment">// 加入活结点队列中</span></span><br><span class="line">            q.<span class="built_in">push</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出当前扩展结点</span></span><br><span class="line">        node curr = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (curr.level &lt; n) <span class="comment">// 未到达叶结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历当前扩展结点的所有子结点，即所有供应商</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                node curr_son = <span class="built_in">node</span>(curr.weight + w[curr.level + <span class="number">1</span>][i], curr.cost + c[curr.level + <span class="number">1</span>][i], curr.level + <span class="number">1</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (curr_son.level == n) <span class="comment">// 如果扩展结点的子结点为叶结点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 最后一个物品选择供应商i</span></span><br><span class="line">                    curr.tmp_x[curr_son.level] = i;</span><br><span class="line">                    <span class="comment">// 符合约束条件且得到更优值时，更新最优值与最优解</span></span><br><span class="line">                    <span class="keyword">if</span> (curr_son.weight &lt; best_w &amp;&amp; curr_son.cost &lt;= d)</span><br><span class="line">                    &#123;</span><br><span class="line">                        best_w = curr_son.weight;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                            best_x[j] = curr.tmp_x[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 如果扩展结点的子结点不是叶结点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curr_son.cost &lt;= d &amp;&amp; curr_son.weight &lt; best_w)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 前面的保持不变</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; curr_son.level; j++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            curr_son.tmp_x[j] = curr.tmp_x[j];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 当前选择第i个供应商(儿子结点)加入到活结点队列中</span></span><br><span class="line">                        curr_son.tmp_x[curr_son.level] = i;</span><br><span class="line">                        q.<span class="built_in">push</span>(curr_son);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; best_w &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; best_x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Lethe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://lethe.site/2022/0320/algorithm_course/">https://lethe.site/2022/0320/algorithm_course/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Algorithm/"># Algorithm</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/0908/Vision-Transformer/">Vision-Transformer(VIT)代码实现</a>
            
            
            <a class="next" rel="next" href="/2022/0317/PointRCNN/">PointRCNN:3D Object Proposal Generation and Detection from Point Cloud</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>Life is a struggle.</span>
        <!-- <span>© Lethe | 2019 - 2022</span> -->
    </div>
</footer>

    </div>
</body>

</html>