<!DOCTYPE html>
<html lang="">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Lethe">


    <meta name="subtitle" content="Life is a struggle">


    <meta name="description" content="Lethe's Blog">


    <meta name="keywords" content="Lethe's Blog">


<title>Python常用模块 | Lethe&#39;s Blog</title>



    <link rel="icon" href="https://s2.ax1x.com/2019/10/30/K5JenU.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Lethe&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Lethe&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Python常用模块</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Lethe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 17, 2019&nbsp;&nbsp;17:11:41</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Study-Notes/">Study Notes</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h4 id="一、sys-—-系统相关的参数和函数"><a href="#一、sys-—-系统相关的参数和函数" class="headerlink" title="一、sys — 系统相关的参数和函数"></a>一、sys — 系统相关的参数和函数</h4><p>sys模块官方文档： <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/sys.html">https://docs.python.org/3/library/sys.html</a></p>
<ul>
<li><strong>sys.argv</strong>：获取运行 Python 程序的命令行参数。其中 sys.argv[0] 通常就是指该 Python 程序，sys.argv[1] 代表为 Python 程序提供的第一个参数，sys.argv[2] 代表为 Python 程序提供的第二个参数……依此类推。</li>
<li><strong>sys.byteorder</strong>：显示本地字节序的指示符。如果本地字节序是大端模式，则该属性返回 big；否则返回 little。</li>
<li><strong>sys.copyright</strong>：该属性返回与 Python 解释器有关的版权信息。</li>
<li><strong>sys.executable</strong>：该属性返回 Python 解释器在磁盘上的存储路径。</li>
<li>**sys.exit()**：通过引发 SystemExit 异常来退出程序。将其放在 try 块中不能阻止 finally 块的执行。</li>
<li><strong>sys.flags</strong>：该只读属性返回运行 Python 命令时指定的旗标。</li>
<li>**sys.getfilesystemencoding()**：返回在当前系统中保存文件所用的字符集。</li>
<li>**sys.getrefcount(object)**：返回指定对象的引用计数。前面介绍过，当 object 对象的引用计数为 0 时，系统会回收该对象。</li>
<li>**sys.getrecursionlimit()**：返回 Python 解释器当前支持的递归深度。该属性可通过 - setrecursionlimit() 方法重新设置。</li>
<li>**sys.getswitchinterval()**：返回在当前 Python 解释器中线程切换的时间间隔。该属性可通过 setswitchinterval() 函数改变。</li>
<li><strong>sys.implementation</strong>：返回当前 Python 解释器的实现。</li>
<li><strong>sys.maxsize</strong>：返回 Python 整数支持的最大值。在 32 位平台上，该属性值为 2**31-1；在 64 位平台上，该属性值为 2**63-1。</li>
<li><strong>sys.modules</strong>：返回模块名和载入模块对应关系的字典。</li>
<li><strong>sys.path</strong>：该属性指定 Python 查找模块的路径列表。程序可通过修改该属性来动态增加 Python 加载模块的路径。</li>
<li><strong>sys.platform</strong>：返回 Python 解释器所在平台的标识符。</li>
<li><strong>sys.stdin</strong>：返回系统的标准输入流——一个类文件对象。</li>
<li><strong>sys.stdout</strong>：返回系统的标准输出流——一个类文件对象。</li>
<li><strong>sys.stderr</strong>：返回系统的错误输出流——一个类文件对象。</li>
<li><strong>sys.version</strong>：返回当前 Python 解释器的版本信息。</li>
<li><strong>sys.winver</strong>：返回当前 Python 解释器的主版本号。</li>
</ul>
<p>例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="comment"># 输出argv列表的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(argv))</span><br><span class="line"><span class="comment"># 遍历argv列表的每个元素</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> argv:</span><br><span class="line">   <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line">如果使用python3 test.py Lethe Python 命令运行该脚本，则结果为：</span><br><span class="line"><span class="number">3</span></span><br><span class="line">test.py</span><br><span class="line">Lethe</span><br><span class="line">Python</span><br></pre></td></tr></table></figure>
<p>sys.path 也是很有用的一个属性，它可用于在程序运行时为 Python 动态修改模块加载路径。例如，如下程序在运行时动态指定加载 <code>E:\Lethe </code>目录下的模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 动态添加g:\fk_ext路径作为模块加载路径</span></span><br><span class="line">sys.path.append(<span class="string">&#x27;E:\\Lethe&#x27;</span>)</span><br><span class="line"><span class="comment"># 加载g:\fk_ext路径下的hello模块</span></span><br><span class="line"><span class="keyword">import</span> hello</span><br></pre></td></tr></table></figure>

<br>

<h4 id="二、os-—-操作系统接口模块"><a href="#二、os-—-操作系统接口模块" class="headerlink" title="二、os — 操作系统接口模块"></a>二、os — 操作系统接口模块</h4><p>os模块官方文档：<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/os.html%E3%80%82">https://docs.python.org/3/library/os.html。</a></p>
<h6 id="（1）os模块与目录相关的函数如下"><a href="#（1）os模块与目录相关的函数如下" class="headerlink" title="（1）os模块与目录相关的函数如下:"></a>（1）os模块与目录相关的函数如下:</h6><ul>
<li>**os.getcwd()**：获取当前目录。</li>
<li>**os.chdir(path)**：改变当前目录。</li>
<li>**os.fchdir(fd)**：通过文件描述利改变当前目录。该函数与上一个函数的功能基本相似，只是该函数以文件描述符作为参数来代表目录。</li>
<li>**s.chroot(path)**：改变当前进程的根目录。</li>
<li>**os.listdir(path)**：返回 path 对应目录下的所有文件和子目录。</li>
<li>**os.mkdir(path[, mode])**：创建 path 对应的目录，其中 mode 用于指定该目录的权限。该 mode参数代表一个 UNIX 风格的权限，比如 0o777 代表所有者可读&#x2F;可写&#x2F;可执行、组用户可读&#x2F;可写&#x2F;可执行、其他用户可读&#x2F;可写&#x2F;可执行。</li>
<li>**os.makedirs(path[, mode])**：其作用类似于 mkdir()，但该函数的功能更加强大，它可以边归创建目录。比如要创建 abc&#x2F;xyz&#x2F;wawa 目录，如果在当前目录下没有 abc 目录，那么使用 mkdir() 函数就会报错，而使用 makedirs() 函数则会先创建 abc，然后在其中创建 xyz 子目录，最后在 xyz 子目录下创建 wawa 子目录。</li>
<li>**os.rmdir(path)**：删除 path 对应的空目录。如果目录非空，则抛出一个 OSError 异常。程序可以先用 os.remove() 函数删除文件。</li>
<li>**os.removedirs(path)**：递归删除目录。其功能类似于 rmdir()，但该函数可以递归删除 abc&#x2F;xyz&#x2F;wawa 目录，它会从 wawa 子目录开始删除，然后删除 xyz 子目录，最后删除 abc 目录。</li>
<li>**os.rename(src, dst)**：重命名文件或目录，将 src 重名为 dst。</li>
<li>**os.renames(old, new)**：对文件或目录进行递归重命名。其功能类似于 rename()，但该函数可以递归重命名 abc&#x2F;xyz&#x2F;wawa 目录，它会从 wawa 子目录开始重命名，然后重命名 xyz 子目录，最后重命名 abc 目录。</li>
</ul>
<p>除此之外，<strong>os.path</strong> 模块下提供了一些操作目录的方法，这些函数可以操作系统的目录本身。</p>
<h6 id="os-path模块下的操作目录的常见函数的功能和用法："><a href="#os-path模块下的操作目录的常见函数的功能和用法：" class="headerlink" title="os.path模块下的操作目录的常见函数的功能和用法："></a>os.path模块下的操作目录的常见函数的功能和用法：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 获取绝对路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&quot;abc.txt&quot;</span>)) <span class="comment"># G:\publish\codes\12\12.2\abc.txt</span></span><br><span class="line"><span class="comment"># 获取共同前缀</span></span><br><span class="line"><span class="built_in">print</span>(os.path.commonprefix([<span class="string">&#x27;/usr/lib&#x27;</span>, <span class="string">&#x27;/usr/local/lib&#x27;</span>])) <span class="comment"># /usr/l</span></span><br><span class="line"><span class="comment"># 获取共同路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.commonpath([<span class="string">&#x27;/usr/lib&#x27;</span>, <span class="string">&#x27;/usr/local/lib&#x27;</span>])) <span class="comment"># \usr</span></span><br><span class="line"><span class="comment"># 获取目录</span></span><br><span class="line"><span class="built_in">print</span>(os.path.dirname(<span class="string">&#x27;abc/xyz/README.txt&#x27;</span>)) <span class="comment">#abc/xyz</span></span><br><span class="line"><span class="comment"># 判断指定目录是否存在</span></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;abc/xyz/README.txt&#x27;</span>)) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 获取最近一次访问时间</span></span><br><span class="line"><span class="built_in">print</span>(time.ctime(os.path.getatime(<span class="string">&#x27;os.path_test.py&#x27;</span>)))</span><br><span class="line"><span class="comment"># 获取最后一次修改时间</span></span><br><span class="line"><span class="built_in">print</span>(time.ctime(os.path.getmtime(<span class="string">&#x27;os.path_test.py&#x27;</span>)))</span><br><span class="line"><span class="comment"># 获取创建时间</span></span><br><span class="line"><span class="built_in">print</span>(time.ctime(os.path.getctime(<span class="string">&#x27;os.path_test.py&#x27;</span>)))</span><br><span class="line"><span class="comment"># 获取文件大小</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getsize(<span class="string">&#x27;os.path_test.py&#x27;</span>))</span><br><span class="line"><span class="comment"># 判断是否为文件</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(<span class="string">&#x27;os.path_test.py&#x27;</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 判断是否为目录</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isdir(<span class="string">&#x27;os.path_test.py&#x27;</span>)) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 判断是否为同一个文件</span></span><br><span class="line"><span class="built_in">print</span>(os.path.samefile(<span class="string">&#x27;os.path_test.py&#x27;</span>, <span class="string">&#x27;./os.path_test.py&#x27;</span>)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h6 id="（2）os模块与文件访问相关的函数如下"><a href="#（2）os模块与文件访问相关的函数如下" class="headerlink" title="（2）os模块与文件访问相关的函数如下:"></a>（2）os模块与文件访问相关的函数如下:</h6><ul>
<li>**os.open(file, flags[, mode])**：打开一个文件，并且设置打开选项，mode 参数是可选的。该函数返回文件描述符。其中 flags 代表打开文件的旗标，它支持如下一个或多个选项：<ul>
<li>os.O_RDONLY：以只读的方式打开。</li>
<li>os.O_WRONLY：以只写的方式打开。</li>
<li>os.O_RDWR：以读写的方式打开。</li>
<li>os.O_NONBLOCK：打开时不阻塞。</li>
<li>os.O_APPEND：以追加的方式打开。</li>
<li>os.O_CREAT：创建并打开一个新文件。</li>
<li>os.O_TRUNC：打开一个文件并截断它的长度为0（必须有写权限）。</li>
<li>os.O_EXCL：在创建文件时，如果指定的文件存在，则返回错误。</li>
<li>os.O_SHLOCK：自动获取共享锁。</li>
<li>os.O_EXLOCK：自动获取独立锁。</li>
<li>os.O_DIRECT：消除或减少缓存效果。</li>
<li>os.O_FSYNC：同步写入。</li>
<li>os.O_NOFOLLOW：不追踪软链接。</li>
</ul>
</li>
<li>**os.read(fd, n)**：从文件描述符 fd 中读取最多 n 个字节，返回读到的字符串。如果文件描述符副对应的文件己到达结尾，则返回一个空字节串。</li>
<li>**os.write(fd, str)**：将字节串写入文件描述符 fd 中，返回实际写入的字节串长度。</li>
<li>**os.close(fd)**：关闭文件描述符 fd。</li>
<li>**os.lseek(fd, pos, how)**：该函数同样用于移动文件指针。其中 how 参数指定从哪里开始移动，如果将 how 设为 0 或 SEEK_SET，则表明从文件开头开始移动；如果将 how 设为 1 或 SEEK_CUR，则表明从文件指针当前位置开始移动；如果将 how 设为 2 或 SEEK_END，则表明从文件结束处开始移动。上面几个函数同样可用于执行文件的读写，程序通常会先通过 os.open() 打开文件，然后调用 os.read()、os.write() 来读写文件，当操作完成后通过 os.close() 关闭文件。</li>
<li>**os.fdopen(fd[, mode[, bufsize]])**：通过文件描述符 fd 打开文件，并返回对应的文件对象。</li>
<li>**os.closerange(fd_low, fd_high)**：关闭从 fd_low（包含）到 fd_high（不包含）范围的所有文件描述符。</li>
<li>**os.dup(fd)**：复制文件描述符。</li>
<li>**os.dup2(fd,fd2)**：将一个文件描述符fd复制到另一个文件描述符fd2中。</li>
<li>**os.ftruncate(fd, length)**：将 fd 对应的文件截断到 length 长度，因此此处传入的 length 参数不应该超过文件大小。</li>
<li>**os.remove(path)**：删除 path 对应的文件。如果 path 是一个文件夹，则抛出 OSError 错误。如果要删除目录，则使用 os.rmdir()。</li>
<li>**os.link(src, dst)**：创建从 src 到 dst 的硬链接。硬链接是 UNIX 系统的概念，如果在 Windows 系统中就是复制目标文件。</li>
<li>**os.symlink(src, dst)**：创建从 src 到 dst 的符号链接，对应于 Windows 的快捷方式。</li>
</ul>
<h6 id="（3）os模块与权限相关的函数"><a href="#（3）os模块与权限相关的函数" class="headerlink" title="（3）os模块与权限相关的函数"></a>（3）os模块与权限相关的函数</h6><ul>
<li>**os.access(path, mode)**：检查 path 对应的文件或目录是否具有指定权限。该函数的第二个参数可能是以下四个状态值的一个或多个值：<ul>
<li>os.F_OK：判断是否存在。</li>
<li>os.R_OK：判断是否可读。</li>
<li>os.W_OK：判断是否可写。</li>
<li>os.X_OK：判断是否可执行。</li>
</ul>
</li>
<li>**os.chrnod(path, mode)**：更改权限。其中 mode 参数代表要改变的权限，该参数支持的值可以是以下一个或多个值的组合：<ul>
<li>stat.S_IXOTH：其他用户有执行权限。</li>
<li>stat.S_IWOTH：其他用户有写权限。</li>
<li>stat.S_TROTH：其他用户有读权限。</li>
<li>stat.S_IRWXO：其他用户有全部权限。</li>
<li>stat.S_IXGRP：组用户有执行权限。</li>
<li>stat.S_IWGRP：组用户有写权限。</li>
<li>stat.S_IRGRP：组用户有读权限。</li>
<li>stat.S_IRWXG：组用户有全部权限。</li>
<li>stat.S_IXUSR：所有者有执行权限。</li>
<li>stat.S_IWUSR：所有者有写权限。</li>
<li>stat.S_IRUSR：所有者有读权限。</li>
<li>stat.S_IRWXU：所有者有全部权限。</li>
<li>stat.S_IREAD：Windows 将该文件设为只读的。</li>
<li>stat.S_IWRITE：Windows 将该文件设为可写的。</li>
</ul>
</li>
<li>os.chown(path, uid, gid)：更改文件的所有者。其中 uid 代表用户 id，gid 代表组 id。该命令主要在 UNIX 文件系统下有效。</li>
<li>os.fchmod(fd, mode)：改变一个文件的访问权限，该文件由文件描述符 fd 指定。该函数的功能与 os.chmod() 函数的功能相似，只是该函数使用 fd 代表文件。</li>
<li>os.fchown(fd, uid, gid)：改变文件的所有者，该文件由文件描述符 fd 指定。该函数的功能与 os.chown() 函数的功能相似，只是该函数使用 fd 代表文件。</li>
</ul>
<h6 id="（4）os模块与进程相关的函数"><a href="#（4）os模块与进程相关的函数" class="headerlink" title="（4）os模块与进程相关的函数"></a>（4）os模块与进程相关的函数</h6><ul>
<li><strong>os.name</strong>：返回导入依赖模块的操作系统名称，通常可返回 ‘posix’、’nt’、 ‘java’ 等值其中之一。</li>
<li>os.environ：返回在当前系统上所有环境变量组成的字典。</li>
<li>**os.fsencode(filename)**：该函数对类路径（path-like）的文件名进行编码。</li>
<li>**os.fsdecode(filename)**：该函数对类路径（path-like）的文件名进行解码。</li>
<li><strong>os.PathLike</strong>：这是一个类，代表一个类路径（path-like）对象。</li>
<li><strong>os.getenv(key, default&#x3D;None）</strong>：获取指定环境变量的值。</li>
<li>**os.getlogin()**：返回当前系统的登录用户名。与该函数对应的还有 os.getuid()、os.getgroups()、os.getgid() 等函数，用于获取用户 ID、用户组、组 ID 等，这些函数通常只在 UNIX 系统上有效。</li>
<li>**os.getpid()**：获取当前进程 ID。</li>
<li><strong>os.getppid()<strong>：获取当前进程的</strong>父进程</strong> ID。</li>
<li>**os.putenv(key, value)**：该函数用于设置环境变量。</li>
<li>**os.cpu_count()**：返回当前系统的 CPU 数量。</li>
<li><strong>os.sep</strong>：返回路径分隔符。</li>
<li><strong>os.pathsep</strong>：返回当前系统上多条路径之间的分隔符。一般在 Windows 系统上多条路径之间的分隔符是英文分号（;）；在 UNIX 及类 UNIX 系统（如 Linux、Mac os X）上多条路径之间的分隔符是英文冒号（:）。</li>
<li><strong>os.linesep</strong>：返回当前系统的换行符。一般在 Windows 系统上换行符是“\r\n”：在 UNIX 系统上换行符是“\n”；在 Mac os X 系统上换行符是“\r”。</li>
<li>**os.urandom(size)**：返回适合作为加密使用的、最多由 N 个字节组成的 bytes 对象。该函数通过操作系统特定的随机性来源返回随机字节，该随机字节通常是不可预测的，因此适用于绝大部分加密场景。</li>
</ul>
<p>在 os 模块下与<strong>进程管理</strong>相关的函数如下：</p>
<ul>
<li><p>**os.abort()**：生成一个 SIGABRT 信号给当前进程。在 UNIX 系统上，默认行为是生成内核转储；在 Windows 系统上，进程立即返回退出代码 3。</p>
</li>
<li><p><strong>os.execl(path, arg0, arg1, …）</strong>：该函数还有一系列功能类似的函数，比如 os.execle()、os.execlp() 等，这些函数都是使用参数列表 arg0, arg1,…来执行 path 所代表的执行文件的。<br><code>由于 os.exec*() 函数都是 PosIX 系统的直接映射，因此如采使用该命令来执行 Python 程序，传入的 arg0 参数没有什么作用。os._exit(n) 用于强制退出 Python 解释器。将其放在 try 决中可以阻止 finally 块的执行。</code></p>
</li>
<li><p>**os.forkpty()**：fork一个子进程。</p>
</li>
<li><p>**os.kill(pid, sig)**：将 sig 信号发送到 pid 对应的过程，用于结束该进程。</p>
</li>
<li><p>**os.killpg(pgid, sig)**：将 sig 信号发送到 pgid 对应的进程组。</p>
</li>
<li><p>**os.popen(cmd, mode&#x3D;’r’, buffering&#x3D;-1)**：用于向 cmd 命令打开读写管道（当 mode 为 r 时为只读管道，当 mode 为 rw 时为读写管道），buffering 缓冲参数与内置的 open() 函数有相同的含义。该函数返回的文件对象用于读写字符串，而不是字节。</p>
</li>
<li><p>**os.spawnl(mode, path, …)**：该函数还有一系列功能类似的函数，比如 os.spawnle()、os.spawnlp() 等，这些函数都用于在新进程中执行新程序。</p>
</li>
<li><p>**os.startfile(path[,operation])**：对指定文件使用该文件关联的工具执行 operation 对应的操作。如果不指定 operation 操作，则默认执行打开（open）操作。operation 参数必须是有效的命令行操作项目，比如 open（打开）、edit（编辑）、print（打印）等。</p>
</li>
<li><p>**os.system(command)**：运行操作系统上的指定命令。</p>
</li>
</ul>
<br>

<h4 id="三、random-—-生成伪随机数"><a href="#三、random-—-生成伪随机数" class="headerlink" title="三、random —  生成伪随机数"></a>三、random —  生成伪随机数</h4><p>random模块官方文档：<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/random.html">https://docs.python.org/3/library/random.html</a></p>
<p>在 random 模块下提供了如下常用函数：</p>
<ul>
<li>**random.seed(a&#x3D;None, version&#x3D;2)**：指定种子来初始化伪随机数生成器。</li>
<li>**random.randrange(start, stop[, stop])**：返回从 start 开始到 stop 结束、步长为 step 的随机数。其实就相当于 choice(range(start, stop, step)) 的效果，只不过实际底层并不生成区间对象。</li>
<li>**random.randint(a, b)**：生成一个范围为 a≤N≤b 的随机数。其等同于 randrange(a, b+1) 的效果。</li>
<li>**random.choice(seq)**：从 seq 中随机抽取一个元素，如果 seq 为空，则引发 IndexError 异常。</li>
<li>**random.choices(seq, weights&#x3D;None, cum_weights&#x3D;None, k&#x3D;1)**：从 seq 序列中抽取 k 个元素，还可通过 weights 指定各元素被抽取的权重（代表被抽取的可能性高低）。</li>
<li>**random.shuffle(x[, random])**：对 x 序列执行洗牌“随机排列”操作。</li>
<li>**random.sample(population, k)**：从 population 序列中随机抽取 k 个独立的元素。</li>
<li>**random.random()**：生成一个从0.0（包含）到 1.0（不包含）之间的伪随机浮点数。</li>
<li>**random.uniform(a, b)**：生成一个范围为 a≤N≤b 的随机数。</li>
<li>**random.expovariate(lambd)**：生成呈指数分布的随机数。其中 lambd 参数(其实应该是 lambda，只是 lambda 是 Python 关键字，所以简写成 lambd）为 1 除以期望平均值。如果 lambd 是正值，则返回的随机数是从 0 到正无穷大；如果 lambd 为负值，则返回的随机数是从负无穷大到 0。</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#生成范围为0.0≤x&lt;1.0 的伪随机浮点数</span></span><br><span class="line"><span class="built_in">print</span> (random.random())</span><br><span class="line"><span class="comment">#生成范围为2.5≤x&lt;10.0 的伪随机浮点数</span></span><br><span class="line"><span class="built_in">print</span> (random.uniform(<span class="number">2.5</span>, <span class="number">10.0</span>))</span><br><span class="line"><span class="comment">#生成呈指数分布的伪随机浮点数</span></span><br><span class="line"><span class="built_in">print</span> (random.expovariate(<span class="number">1</span>/<span class="number">5</span>))</span><br><span class="line"><span class="comment">#生成从0 到9 的伪随机整数</span></span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">10</span>))</span><br><span class="line"><span class="comment">#生成从0 到100 的随机偶数</span></span><br><span class="line"><span class="built_in">print</span> (random.randrange(<span class="number">0</span>, <span class="number">101</span> , <span class="number">2</span>))</span><br><span class="line"><span class="comment">#随机抽取一个元素</span></span><br><span class="line"><span class="built_in">print</span> (random.choice ([<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;Swift&#x27;</span>,<span class="string">&#x27;Kotlin&#x27;</span>]))</span><br><span class="line">book_list = [<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;Swift&#x27;</span>,<span class="string">&#x27;Kotlin&#x27;</span>]</span><br><span class="line"><span class="comment">#对列表元素进行随机排列</span></span><br><span class="line">random.shuffle (book_list)</span><br><span class="line"><span class="built_in">print</span> (book_list)</span><br><span class="line"><span class="comment">#随机抽取4 个独立的元素</span></span><br><span class="line"><span class="built_in">print</span> (random.sample([<span class="number">10</span>, <span class="number">20</span> , <span class="number">30</span> , <span class="number">40</span> , <span class="number">50</span>], k=<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<br>

<h4 id="四、time-—-时间的访问和转换"><a href="#四、time-—-时间的访问和转换" class="headerlink" title="四、time — 时间的访问和转换"></a>四、time — 时间的访问和转换</h4><p>time模块官方文档：<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/time.html#module-time">https://docs.python.org/zh-cn/3/library/time.html#module-time</a></p>
<p>在日期、时间模块内常用的功能函数如下：</p>
<ul>
<li><p>**time.asctime([t])**：将时间元组或 struct_time 转换为时间字符串。如果不指定参数 t，则默认转换当前时间。</p>
</li>
<li><p>**time.ctime([secs])**：将以秒数代表的时间转换为时间宇符串。<br><code>Python 可以用从 1970 年 1 月 1 日 0 点整到现在所经过的秒数来代表当前时间，比如我们写 30 秒，那么意味着时间是 1970 年 1 月 1 日 0 点 0 分 30 秒。但需要注意的是，在实际输出时可能会受到时区的影响，比如中国处于东八区，因此实际上会输出 1970 年 1 月 1 日 8 点 0 分 30 秒。</code></p>
</li>
<li><p>**time.gmtime([secs])**：将以秒数代表的时间转换为 struct_time 对象。如果不传入参数，则使用当前时间。</p>
</li>
<li><p>**time.localtime([secs])**：将以秒数代表的时间转换为代表当前时间的 struct_time 对象。如果不传入参数，则使用当前时间。</p>
</li>
<li><p>**time.mktime(t)**：它是 localtime 的反转函数，用于将 struct_time 对象或元组代表的时间转换为从 1970 年 1 月 1 日 0 点整到现在过了多少秒。</p>
</li>
<li><p>**time.perf_counter()**：返回性能计数器的值。以秒为单位。</p>
</li>
<li><p>**time.process_time()**：返回当前进程使用 CPU 的时间。以秒为单位。</p>
</li>
<li><p>**time.sleep(secs)**：暂停 secs 秒，什么都不干。</p>
</li>
<li><p>**time.strftime(format[, t])**：将时间元组或 struct_time 对象格式化为指定格式的时间字符串。如果不指定参数 t，则默认转换当前时间。</p>
</li>
<li><p>**time.strptime(string[, format])**：将字符串格式的时间解析成 struct_time 对象。</p>
</li>
<li><p>**time.time()**：返回从 1970 年 1 月 1 日 0 点整到现在过了多少秒。</p>
</li>
<li><p><strong>time.timezone</strong>：返回本地时区的时间偏移，以秒为单位。</p>
</li>
<li><p><strong>time.tzname</strong>：返回本地时区的名字。</p>
</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 将当前时间转换为时间字符串</span></span><br><span class="line"><span class="built_in">print</span>(time.asctime())</span><br><span class="line"><span class="comment"># 将指定时间转换时间字符串，时间元组的后面3个元素没有设置</span></span><br><span class="line"><span class="built_in">print</span>(time.asctime((<span class="number">2018</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>))) <span class="comment"># Mon Feb  4 11:08:23 2018</span></span><br><span class="line"><span class="comment"># 将以秒数为代表的时间转换为时间字符串</span></span><br><span class="line"><span class="built_in">print</span>(time.ctime(<span class="number">30</span>)) <span class="comment"># Thu Jan  1 08:00:30 1970</span></span><br><span class="line"><span class="comment"># 将以秒数为代表的时间转换为struct_time对象。</span></span><br><span class="line"><span class="built_in">print</span>(time.gmtime(<span class="number">30</span>))</span><br><span class="line"><span class="comment"># 将当前时间转换为struct_time对象。</span></span><br><span class="line"><span class="built_in">print</span>(time.gmtime())</span><br><span class="line"><span class="comment"># 将以秒数为代表的时间转换为代表当前时间的struct_time对象</span></span><br><span class="line"><span class="built_in">print</span>(time.localtime(<span class="number">30</span>))</span><br><span class="line"><span class="comment"># 将元组格式的时间转换为秒数代表的时间</span></span><br><span class="line"><span class="built_in">print</span>(time.mktime((<span class="number">2018</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span> ,<span class="number">0</span>))) <span class="comment"># 1517713703.0</span></span><br><span class="line"><span class="comment"># 返回性能计数器的值</span></span><br><span class="line"><span class="built_in">print</span>(time.perf_counter())</span><br><span class="line"><span class="comment"># 返回当前进程使用CPU的时间</span></span><br><span class="line"><span class="built_in">print</span>(time.process_time())</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)	<span class="comment"># 暂停10s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前时间转换为指定格式的字符串</span></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span><br><span class="line">st = <span class="string">&#x27;2018年3月20日&#x27;</span></span><br><span class="line"><span class="comment"># 将指定时间字符串恢复成struct_time对象。</span></span><br><span class="line"><span class="built_in">print</span>(time.strptime(st, <span class="string">&#x27;%Y年%m月%d日&#x27;</span>))</span><br><span class="line"><span class="comment"># 返回从1970年1970年1月1日0点整到现在过了多少秒。</span></span><br><span class="line"><span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="comment"># 返回本地时区的时间偏移，以秒为单位</span></span><br><span class="line"><span class="built_in">print</span>(time.timezone) <span class="comment"># 在国内东八区输出-28800</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="五、json-—-JSON-编码和解码器"><a href="#五、json-—-JSON-编码和解码器" class="headerlink" title="五、json — JSON 编码和解码器"></a>五、json — JSON 编码和解码器</h4><p>json模块官方文档：<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/json.html#module-json">https://docs.python.org/zh-cn/3/library/json.html#module-json</a></p>
<p>JSON 类型转换Python 类型的对应关系：<br><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/Learn-Common-Python-modules/2019071715493289.png" alt="在这里插入图片描述"></p>
<p> Python 类型转换 JSON 类型的对应关系：<br><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/Learn-Common-Python-modules/20190717155051629.png" alt="在这里插入图片描述"><br>json 模块中常用的函数和类的功能如下：</p>
<ul>
<li>**json.dump(obj, fp, *, skipkeys&#x3D;False, ensure_ascii&#x3D;True, check_circular&#x3D;True, allow_nan&#x3D;True, cls&#x3D;None, indent&#x3D;None, separators&#x3D;None, default&#x3D;None, sort_keys&#x3D;False, **kw)**：将 obj 对象转换成 JSON 字符串输出到 fp 流中，fp 是一个支持 write() 方法的类文件对象。</li>
<li>**json.dumps(obj, *, skipkeys&#x3D;False, ensure_ascii&#x3D;True, check_circular&#x3D;True, allow_nan&#x3D; True, cls&#x3D;None, indent&#x3D;None, separators&#x3D;None, default&#x3D;None, sort_keys&#x3D;False, **kw)**：将 obj 对象转换为 JSON 字符串，并返回该JSON 字符串。</li>
<li>**json.load(fp, *, cls&#x3D;None, object_hook&#x3D;None, parse_float&#x3D;None, parse_int&#x3D;None, parse_constant&#x3D;None, object_pairs_hook&#x3D;None, **kw)**：从 fp 流读取 JSON 字符串，将其恢复成 JSON 对象，其中 fp 是一个支持 write() 方法的类文件对象。</li>
<li>**json.loads(s, *, encoding&#x3D;None, cls&#x3D;None, object_hook&#x3D;None, parse_float&#x3D;None, parse_int&#x3D;None, parse_constant&#x3D;None, object_pairs_hook&#x3D;None, **kw)**：将 JSON 字符串 s 恢复成 JSON 对象。<br><img src="https://cdn.jsdelivr.net/gh/LetheSec/oss@master/Blog/Learn-Common-Python-modules/20190717155333993.png" alt="在这里插入图片描述"></li>
</ul>
<p>dumps() 和 dump() 函数的 encode 操作（将 Python 对象转换成 JSON 字符串）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 将Python对象转JSON字符串（元组会当成数组）</span></span><br><span class="line">s = json.dumps([<span class="string">&#x27;yeeku&#x27;</span>, &#123;<span class="string">&#x27;favorite&#x27;</span>: (<span class="string">&#x27;coding&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;game&#x27;</span>, <span class="number">25</span>)&#125;])</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># [&quot;yeeku&quot;, &#123;&quot;favorite&quot;: [&quot;coding&quot;, null, &quot;game&quot;, 25]&#125;]</span></span><br><span class="line"><span class="comment"># 简单的Python字符串转JSON</span></span><br><span class="line">s2 = json.dumps(<span class="string">&quot;\&quot;foo\bar&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s2) <span class="comment">#&quot;\&quot;foo\bar&quot;</span></span><br><span class="line"><span class="comment"># 简单的Python字符串转JSON</span></span><br><span class="line">s3 = json.dumps(<span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s3) <span class="comment">#&quot;\\&quot;</span></span><br><span class="line"><span class="comment"># Python的dict对象转JSON，并对key排序</span></span><br><span class="line">s4 = json.dumps(&#123;<span class="string">&quot;c&quot;</span>: <span class="number">0</span>, <span class="string">&quot;b&quot;</span>: <span class="number">0</span>, <span class="string">&quot;a&quot;</span>: <span class="number">0</span>&#125;, sort_keys=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(s4) <span class="comment">#&#123;&quot;a&quot;: 0, &quot;b&quot;: 0, &quot;c&quot;: 0&#125;</span></span><br><span class="line"><span class="comment"># 将Python列表转JSON，</span></span><br><span class="line"><span class="comment"># 并指定JSON分隔符：逗号和冒号之后没有空格（默认有空格）</span></span><br><span class="line">s5 = json.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">7</span>&#125;], separators=(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;:&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出的JSON字符串中逗号和冒号之后没有空格</span></span><br><span class="line"><span class="built_in">print</span>(s5) <span class="comment"># &#x27;[1,2,3,&#123;&quot;4&quot;:5,&quot;6&quot;:7&#125;]&#x27;</span></span><br><span class="line"><span class="comment"># 指定indent为4，意味着转换的JSON字符串有缩进</span></span><br><span class="line">s6 = json.dumps(&#123;<span class="string">&#x27;Python&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;Kotlin&#x27;</span>: <span class="number">7</span>&#125;, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(s6)</span><br><span class="line"><span class="comment"># 使用JSONEncoder的encode方法将Python转JSON</span></span><br><span class="line">s7 = json.JSONEncoder().encode(&#123;<span class="string">&quot;names&quot;</span>: (<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;齐天大圣&quot;</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(s7) <span class="comment"># &#123;&quot;names&quot;: [&quot;\u5b59\u609f\u7a7a&quot;, &quot;\u9f50\u5929\u5927\u5723&quot;]&#125;</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;a.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用dump()函数将转换得到JSON字符串输出到文件</span></span><br><span class="line">json.dump([<span class="string">&#x27;Kotlin&#x27;</span>, &#123;<span class="string">&#x27;Python&#x27;</span>: <span class="string">&#x27;excellent&#x27;</span>&#125;], f)</span><br></pre></td></tr></table></figure>

<p> loads() 和 load() 函数的 decode 操作（将 JSON 字符串转换成 Python 对象）：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 将JSON字符串恢复成Python列表</span></span><br><span class="line">result1 = json.loads(<span class="string">&#x27;[&quot;yeeku&quot;, &#123;&quot;favorite&quot;: [&quot;coding&quot;, null, &quot;game&quot;, 25]&#125;]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result1) <span class="comment"># [&#x27;yeeku&#x27;, &#123;&#x27;favorite&#x27;: [&#x27;coding&#x27;, None, &#x27;game&#x27;, 25]&#125;]</span></span><br><span class="line"><span class="comment"># 将JSON字符串恢复成Python字符串</span></span><br><span class="line">result2 = json.loads(<span class="string">&#x27;&quot;\\&quot;foo\\&quot;bar&quot;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result2) <span class="comment"># &quot;foo&quot;bar</span></span><br><span class="line"><span class="comment"># 定义一个自定义的转化函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">as_complex</span>(<span class="params">dct</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;__complex__&#x27;</span> <span class="keyword">in</span> dct:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">complex</span>(dct[<span class="string">&#x27;real&#x27;</span>], dct[<span class="string">&#x27;imag&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> dct</span><br><span class="line"><span class="comment"># 使用自定义的恢复函数</span></span><br><span class="line"><span class="comment"># 自定义回复函数将real数据转成复数的实部，将imag转成复数的虚部</span></span><br><span class="line">result3 = json.loads(<span class="string">&#x27;&#123;&quot;__complex__&quot;: true, &quot;real&quot;: 1, &quot;imag&quot;: 2&#125;&#x27;</span>,\</span><br><span class="line">    object_hook=as_complex)</span><br><span class="line"><span class="built_in">print</span>(result3) <span class="comment"># (1+2j)</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;a.json&#x27;</span>)</span><br><span class="line"><span class="comment"># 从文件流恢复JSON列表</span></span><br><span class="line">result4 = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(result4) <span class="comment"># [&#x27;Kotlin&#x27;, &#123;&#x27;Python&#x27;: &#x27;excellent&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="六、re-—-正则表达式操作"><a href="#六、re-—-正则表达式操作" class="headerlink" title="六、re — 正则表达式操作"></a>六、re — 正则表达式操作</h4><p>re模块官方文档：<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/re.html#module-re">https://docs.python.org/zh-cn/3/library/re.html#module-re</a></p>
<ul>
<li>**re.compile(pattern, flags&#x3D;0)**：该函数用于将正则表达式字符串编译成 _sre.SRE_Pattern 对象，该对象代表了正则表达式编译之后在内存中的对象，它可以缓存并复用正则表达式字符串。如果程序需要多次使用同一个正则表达式字符串，则可考虑先编译它。</li>
<li>**re.match(pattern, string, flags&#x3D;0)**：尝试从字符串的开始位置来匹配正则表达式，如果从开始位置匹配不成功，match() 函数就返回 None 。其中 pattern 参数代表正则表达式；string 代表被匹配的字符串；flags 则代表正则表达式的匹配旗标。该函数返回 _sre.SRE_Match 对象，该对象包含的 span(n) 方法用于获取第 n+1 个组的匹配位置，group(n) 方法用于获取第 n+1 个组所匹配的子串</li>
<li>**re.search(pattern, string, flags&#x3D;0)**：扫描整个字符串，并返回字符串中第一处匹配 pattern 的匹配对象。其中 pattern 参数代表正则表达式；string 代表被匹配的字符串；flags 则代表正则表达式的匹配旗标。该函数也返回 _sre.SRE_Match 对象。</li>
</ul>
<p>match() 与 search() 的区别在于，match() 必须从字符串开始处就匹配，但 search() 可以搜索整个字符串。例如如下程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">m1 = re.match(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.lethe.site&#x27;</span>)<span class="comment"># 开始位置可以匹配</span></span><br><span class="line"><span class="built_in">print</span>(m1.span())  <span class="comment"># span返回匹配的位置</span></span><br><span class="line"><span class="built_in">print</span>(m1.group()) <span class="comment"># group返回匹配的组</span></span><br><span class="line"><span class="built_in">print</span>(re.match(<span class="string">&#x27;lethe&#x27;</span>, <span class="string">&#x27;www.lethe.site&#x27;</span>)) <span class="comment"># 开始位置匹配不到，返回None</span></span><br><span class="line">m2 = re.search(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.lethe.site&#x27;</span>) <span class="comment"># 开始位置可以匹配</span></span><br><span class="line"><span class="built_in">print</span>(m2.span())</span><br><span class="line"><span class="built_in">print</span>(m2.group())</span><br><span class="line">m3 = re.search(<span class="string">&#x27;lethe&#x27;</span>, <span class="string">&#x27;www.lethe.site&#x27;</span>) <span class="comment"># 中间位置可以匹配，返回Match对象</span></span><br><span class="line"><span class="built_in">print</span>(m3.span())</span><br><span class="line"><span class="built_in">print</span>(m3.group())</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">www</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">www</span><br><span class="line">(<span class="number">4</span>, <span class="number">9</span>)</span><br><span class="line">lethe</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>re.findall(pattern, string, flags&#x3D;0)<strong>：扫描整个字符串，并返回字符串中所有匹配 pattern 的子串组成的</strong>列表</strong>。其中 pattern 参数代表正则表达式；string 代表被匹配的宇符串；flags 则代表正则表达式的匹配旗标。</li>
<li><strong>re.finditer(pattern, string, flags&#x3D;0)<strong>：扫描整个字符串，并返回字符串中所有匹配 pattern 的子串组成的</strong>迭代器</strong>，迭代器的元素是 _sre.SRE_Match 对象。其中 pattern 参数代表正则表达式；string 代表被匹配的字符串；flags 则代表正则表达式的匹配旗标。</li>
</ul>
<p>对比 findall()、finditer() 和 search() 函数，search() 只返回字符串中第一处匹配 pattern 的子串；而 findall() 和 finditer() 则返回字符串中所有匹配 pattern 的子串。</p>
<ul>
<li>**re.fullmatch(pattem, string, flags&#x3D;0)**：该函数要求整个字符串能匹配 pattern，如果匹配则返回包含匹配信息的 _sre.SRE_Match 对象；否则返回 None。</li>
<li>**re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)**：该函数用于将 string 字符串中所有匹配 pattern 的内容替换成 repl；repl 既可是被替换的字符串，也可是一个函数。count 参数控制最多替换多少次，如果指定 count 为 0 ，则表示全部首换。</li>
<li>**re.split(pattem, string, maxsplit&#x3D;0, flags&#x3D;0)**：使用 pattern 对 string 进行分割，该函数返回分割得到的多个子串组成的列表。其中 maxsplit 参数控制最多分割几次</li>
<li>**re.purge()**：清除正则表达式缓存。</li>
<li>**re.escape(pattern)**：对模式中除 ASCII 字符、数值、下画线（_）之外的其他字符进行转义。</li>
</ul>
<p>re 模块中的 Match 对象（其具体类型为 _sre.SRE_Match）则是 match()、search() 方法的返回值，该对象中包含了详细的正则表达式匹配信息，包括正则表达式匹配的位置、正则表达式所匹配的子串。</p>
<p>sre.SRE_Match 对象包含了如下方法或属性：</p>
<ul>
<li>**match.group([group1,…])**：获取该匹配对象中指定组所匹配的字符串。</li>
<li>**match.<strong>getitem</strong>(g)**：这是 match.group(g) 的简化写法。由于 match 对象提供了 <strong>getitem</strong>() 方法，因此程序可使用 match[g] 来代替 match.group(g)。</li>
<li>**match.groups(default&#x3D;None)**：返回 match 对象中所有组所匹配的字符串组成的元组。</li>
<li>**match.groupdict(default&#x3D; None)**：返回 match 对象中所有组所匹配的字符串组成的字典。</li>
<li>**match.start([group])**：获取该匹配对象中指定组所匹配的字符串的开始位置。</li>
<li>**match.end([group])**：获取该匹配对象中指定组所匹配的宇符串的结束位置。</li>
<li>**match.span([group])**：获取该匹配对象中指定组所匹配的字符串的开始位置和结束位置。该方法相当于同时返回 start() 和 end() 方法的返回值。</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Lethe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://lethe.site/2019/0717/Learn-Common-Python-modules/">https://lethe.site/2019/0717/Learn-Common-Python-modules/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2022 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Python/"># Python</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/0719/implements-multi-threaded-download-scripts-by-Python/">Python实现多线程下载脚本</a>
            
            
            <a class="next" rel="next" href="/2019/0716/SQL-injection-summary/">SQL注入总结</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>Life is a struggle.</span>
        <!-- <span>© Lethe | 2019 - 2022</span> -->
    </div>
</footer>

    </div>
</body>

</html>